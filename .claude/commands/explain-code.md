---
name: explain-code
description: 智能分析并解释指定代码的功能、逻辑和实现原理，支持逐行解析。该命令专门用于代码理解、学习分析和技术解释，能够深入分析代码结构、算法逻辑和设计模式，为开发者提供清晰的代码解析和技术说明。
argument-hint: [代码位置或代码片段]
---

# 命令参数说明

- **代码位置或代码片段** (必需): 可以是以下几种形式
  - 文件路径: 如 `src/player_controller.gd:12-45` (指定行数范围)
  - 文件路径: 如 `scripts/game_manager.gd` (整个文件)
  - 代码片段: 直接粘贴需要分析的代码块
  - 函数名: 如 `PlayerController.move_player()` (特定函数)
  - 类名: 如 `class PlayerController` (整个类)

# 执行步骤

**当前分析目标**: $ARGUMENTS

## 第一阶段：代码获取与预处理
### 工具使用：filesystem

1. **代码输入识别与解析**
   - 识别输入类型（文件路径、代码片段、函数名等）
   - 如果 **$1** 是文件路径，使用 filesystem 读取相应文件
   - 如果指定了行数范围，提取指定行数的内容
   - 如果 **$1** 是代码片段，直接使用输入的代码

2. **代码结构预处理**
   - 分析代码的语言类型和语法结构
   - 识别主要的代码块（函数、类、循环等）
   - 提取关键的变量和函数调用
   - 准备代码的语法高亮和格式化显示

## 第二阶段：深度代码分析
### 工具使用：sequential-thinking + memory

1. **代码结构分析** (使用 sequential-thinking 工具)
   - 分析代码的整体架构和组织结构
   - 识别设计模式和编程范式
   - 理解代码模块间的依赖关系
   - 评估代码的可读性和维护性

2. **算法逻辑解析** (使用 sequential-thinking 工具)
   - 逐行分析代码的执行逻辑
   - 解释复杂算法的工作原理
   - 分析数据结构和控制流程
   - 识别关键的计算步骤和决策点

3. **技术实现细节分析** (使用 memory 工具)
   - 查询相关的技术文档和最佳实践
   - 解释特定API或框架的使用方法
   - 分析性能考虑和优化技巧
   - 识别潜在的问题和改进建议

## 第三阶段：多维度解释生成
### 工具使用：sequential-thinking + memory

1. **逐行代码解析**
   - 为每一行或代码块提供详细解释
   - 说明变量的作用和值的来源
   - 解释函数调用的参数和返回值
   - 分析条件判断的逻辑和结果

2. **功能层面解释**
   - 从高层次描述代码的主要功能
   - 说明代码在项目中的作用和重要性
   - 解释代码如何与其他模块交互
   - 分析代码的输入输出和处理流程

3. **设计思路分析**
   - 解释开发者选择特定实现方式的原因
   - 分析代码中体现的设计原则和模式
   - 评估实现的优缺点和适用场景
   - 提供可能的改进方案和替代实现

## 第四阶段：学习指导生成
### 工具使用：memory + filesystem

1. **学习要点总结**
   - 提取代码中的关键技术点
   - 总结值得学习的编程技巧
   - 识别常见的设计模式和最佳实践
   - 强调需要特别注意的实现细节

2. **扩展知识建议**
   - 基于代码内容推荐相关的学习资源
   - 建议深入理解的相关技术概念
   - 提供实践练习和改进方向
   - 推荐相似功能的实现案例

# Agent 与 MCP 工具指定

## 主要执行 Agent

### senior-code-reviewer (主导 Agent)
- **使用阶段**: 第二阶段和第三阶段
- **核心职责**: 深度代码分析、逐行解析、技术实现解释
- **专业能力**: 代码异味识别、错误调试分析、代码质量保证、最佳实践实施
- **主要工具**:
  - `sequential-thinking`: 复杂代码逻辑分析和设计决策解释
  - `memory`: 查询编程知识库和最佳实践
  - `filesystem`: 代码文件读取和结构分析

### general-purpose (支持 Agent)
- **使用阶段**: 第一阶段代码获取和第四阶段学习指导
- **核心职责**: 代码预处理、学习资源搜集、扩展知识整理
- **专业能力**: 信息搜索、知识整理、学习指导
- **主要工具**:
  - `filesystem`: 文件操作和代码读取
  - `tavily-mcp`: 搜索相关学习资源和技术文档
  - `memory`: 存储和查询编程知识点

## MCP 工具使用策略

### 1. filesystem 工具
- **使用时机**: 第一阶段代码获取
- **具体用途**:
  - 读取指定路径的代码文件
  - 提取特定行数范围的代码片段
  - 分析项目的整体代码结构
  - 获取相关的依赖文件和配置
- **操作策略**: 根据输入类型智能选择合适的读取方式

### 2. sequential-thinking 工具
- **使用时机**: 第二阶段和第三阶段深度分析
- **具体用途**:
  - 逐步分析复杂的代码逻辑
  - 理解代码的设计思路和实现原理
  - 评估代码质量和潜在问题
  - 生成结构化的解释和分析
- **思考深度**: 根据代码复杂度调整分析步骤的详细程度

### 3. memory 工具
- **使用时机**: 全程知识支持和查询
- **具体用途**:
  - 存储代码分析中的重要发现
  - 查询相关的编程知识和技术文档
  - 记录最佳实践和设计模式
  - 建立知识点间的关联关系
- **记忆策略**: 为重要代码概念建立独立的知识实体

### 4. tavily-mcp 工具
- **使用时机**: 第四阶段学习资源扩展
- **具体用途**:
  - 搜索相关的技术文档和教程
  - 查找最佳实践和编程指南
  - 获取特定技术的最新发展和趋势
  - 收集相似代码的实现案例
- **搜索策略**: 使用代码关键词+技术概念进行精准搜索

# 交付件说明

## 主要交付物清单

### 1. 代码分析报告 (Code Analysis Report)
**文件名格式**: `code_analysis_[函数/文件名]_[日期].md`

**包含内容**:
- 代码基本信息（文件路径、语言、大小等）
- 整体功能概述和主要作用
- 代码结构分析和模块划分
- 设计模式和编程范式识别
- 代码质量评估和改进建议

**文档结构**:
```markdown
# 代码分析报告：[代码标识]

## 1. 基本信息
- **文件路径**: [具体路径]
- **代码语言**: [编程语言]
- **代码行数**: [行数统计]
- **最后修改**: [修改时间]

## 2. 功能概述
### 2.1 主要功能
### 2.2 在项目中的作用
### 2.3 输入输出接口

## 3. 结构分析
### 3.1 代码组织结构
### 3.2 主要模块划分
### 3.3 依赖关系分析
```

### 2. 逐行代码解析 (Line-by-Line Explanation)
**文件名格式**: `line_explanation_[函数/文件名]_[日期].md`

**包含内容**:
- 每行或代码块的详细解释
- 变量声明和作用说明
- 函数调用和参数分析
- 控制流程和逻辑判断解析
- 关键算法的实现原理

**文档结构**:
```markdown
# 逐行代码解析：[代码标识]

## 代码原文
```[语言]
[格式化的代码原文]
```

## 逐行解析

### 第1-5行：导入和声明
**代码**: [具体代码]
**解释**: [详细说明]

### 第6-15行：核心逻辑
**代码**: [具体代码]
**解释**: [详细说明]
```

### 3. 技术实现深度解析 (Technical Deep Dive)
**文件名格式**: `tech_deep_dive_[函数/文件名]_[日期].md`

**包含内容**:
- 算法和数据结构详细分析
- 性能考虑和优化技巧
- 错误处理和边界条件
- 扩展性和维护性分析
- 安全性考虑和最佳实践

**文档结构**:
```markdown
# 技术实现深度解析：[代码标识]

## 1. 算法分析
### 1.1 时间复杂度分析
### 1.2 空间复杂度分析
### 1.3 算法优化建议

## 2. 数据结构选择
### 2.1 数据结构说明
### 2.2 选择理由分析
### 2.3 替代方案比较

## 3. 性能考虑
### 3.1 性能瓶颈识别
### 3.2 优化建议
### 3.3 基准测试建议
```

### 4. 学习指导文档 (Learning Guide)
**文件名格式**: `learning_guide_[主题]_[日期].md`

**包含内容**:
- 关键技术点总结
- 学习路径建议
- 相关知识扩展
- 实践练习建议
- 参考资源和推荐阅读

**文档结构**:
```markdown
# 学习指导：[相关技术主题]

## 1. 核心概念
### 1.1 关键技术点
### 1.2 重要概念解释
### 1.3 术语表

## 2. 学习路径
### 2.1 基础知识要求
### 2.2 学习顺序建议
### 2.3 实践步骤规划

## 3. 扩展学习
### 3.2 相关技术栈
### 3.3 进阶主题
### 3.4 行业最佳实践
```

### 5. 交互式解释报告 (Interactive Explanation)
**实时输出**: 在对话中直接提供结构化的解释

**包含内容**:
- 代码功能简述
- 关键实现要点
- 设计思路分析
- 使用示例和测试
- 常见问题和解决方案

**输出格式**:
```markdown
## 📋 代码功能简述
[1-2句话概括代码的主要功能]

## 🔍 关键实现要点
- **要点1**: [具体说明]
- **要点2**: [具体说明]
- **要点3**: [具体说明]

## 💡 设计思路分析
[分析代码的设计思路和实现选择]

## 📝 使用示例
[提供具体的使用示例]

## ⚠️ 常见问题
[列出常见的问题和解决方案]
```

## 输出格式标准

### 代码展示格式
- **语法高亮**: 使用适当的语言标识进行语法高亮
- **行号标注**: 为重要的代码片段添加行号
- **关键标注**: 使用注释或标记突出关键代码行
- **代码分段**: 将长代码按逻辑功能分段显示

### 解释文本格式
- **层次化结构**: 使用清晰的标题层次组织内容
- **重点突出**: 使用粗体、斜体等强调重要概念
- **列表化**: 使用项目符号列表组织要点信息
- **代码引用**: 使用行号或函数名准确引用代码位置

### 图表和说明
- **流程图**: 使用mermaid图表展示复杂逻辑流程
- **结构图**: 展示代码的模块结构和调用关系
- **时序图**: 描述代码的执行时序和交互过程
- **表格对比**: 比较不同实现方案的优缺点

# 约束与限制条件

## 分析约束条件

### 代码复杂度约束
- **可分析长度**: 单次分析代码不超过500行
- **复杂度限制**: 避免分析过于复杂的嵌套逻辑
- **文件数量**: 优先分析单个文件，跨文件分析需要明确指定
- **深度控制**: 分析深度控制在合理的范围内，避免过度深入

### 技术范围约束
- **语言支持**: 支持主流编程语言（GDScript、Python、JavaScript、C++等）
- **框架限制**: 主要支持Godot引擎相关代码，其他框架需要明确说明
- **版本兼容**: 考虑不同版本的API和语法差异
- **环境依赖**: 分析结果考虑运行环境的特殊要求

### 准确性约束
- **动态分析**: 主要进行静态代码分析，无法预测运行时行为
- **上下文限制**: 缺少完整项目上下文时分析可能不够全面
- **意图推测**: 无法完全了解开发者的原始设计意图
- **外部依赖**: 对外部库和服务的了解可能有限

## 使用约束条件

### 输入格式约束
- **路径格式**: 必须使用有效的文件路径或明确的代码片段
- **权限要求**: 只能分析有读取权限的文件内容
- **大小限制**: 单个文件大小不超过1MB
- **编码要求**: 文件必须使用标准文本编码（UTF-8等）

### 输出质量约束
- **解释准确性**: 确保代码解释的技术准确性
- **可读性要求**: 解释内容应该易于理解和技术正确
- **完整性保证**: 提供足够详细的分析和说明
- **实用性导向**: 解释应该具有实际的学习和使用价值

## 伦理约束条件

### 知识产权约束
- **版权保护**: 尊重代码的版权和知识产权
- **机密信息**: 避免分析和解释包含敏感信息的代码
- **商业机密**: 不分析和泄露商业机密代码
- **授权检查**: 确保有权限分析指定的代码

### 使用限制约束
- **学习目的**: 主要用于学习和理解代码，不用于恶意用途
- **改进导向**: 分析结果应该用于代码改进和技能提升
- **合规使用**: 确保代码分析符合相关法律法规
- **专业操守**: 遵循软件工程的专业道德标准

# 使用场景与最佳实践

## 适用场景

### 学习理解场景
- **代码学习**: 帮助初学者理解复杂的代码实现
- **技术解析**: 深入分析特定技术的实现方式
- **最佳实践学习**: 理解和采纳优秀的编程实践
- **设计模式识别**: 识别和学习代码中的设计模式

### 代码审查场景
- **代码质量评估**: 评估代码的质量和可维护性
- **问题识别**: 发现代码中的潜在问题和改进点
- **重构建议**: 提供代码重构和优化的建议
- **标准化检查**: 检查代码是否符合编程规范

### 项目交接场景
- **代码文档化**: 为现有代码生成详细的技术文档
- **知识转移**: 帮助团队成员理解项目代码结构
- **培训支持**: 为新成员提供代码学习和理解支持
- **维护准备**: 为代码维护提供必要的技术说明

### 技术研究场景
- **算法分析**: 深入分析特定算法的实现细节
- **性能研究**: 分析代码的性能特征和优化空间
- **架构分析**: 理解代码的架构设计和模块关系
- **技术选型**: 评估特定技术方案的优缺点

## 不适用场景

### 运行时调试场景
- **动态错误**: 无法分析和解决运行时错误
- **性能调优**: 不能替代专业的性能分析工具
- **内存泄漏**: 无法检测运行时的内存问题
- **并发问题**: 难以分析复杂的并发和同步问题

### 商业评估场景
- **商业价值**: 不评估代码的商业价值和市场前景
- **成本分析**: 不进行开发成本和工时估算
- **风险评估**: 不进行项目的商业风险评估
- **市场竞争**: 不分析产品的市场竞争状况

### 法律合规场景
- **版权侵权**: 不进行版权侵权的法律分析
- **专利评估**: 不评估代码的专利风险
- **合规检查**: 不进行法律法规的合规性检查
- **审计支持**: 不作为正式的代码审计工具

## 最佳实践指南

### 输入优化建议

#### 代码选择策略
- **针对性选择**: 选择具有代表性和学习价值的代码片段
- **完整功能**: 选择功能相对完整的代码模块
- **适中复杂度**: 避免过于简单或过于复杂的代码
- **清晰结构**: 选择结构清晰、注释良好的代码

#### 分析范围设定
- **明确目标**: 明确代码分析的具体目标和关注点
- **合理边界**: 设定合理的分析边界和深度
- **优先级排序**: 根据重要性确定分析的优先级
- **分阶段进行**: 复杂代码可以分阶段进行分析

### 输出使用建议

#### 学习应用
- **实践结合**: 将分析结果与实际编程实践相结合
- **举一反三**: 从分析中学习通用的编程原理
- **笔记记录**: 建立个人代码知识库和笔记系统
- **定期复习**: 定期回顾重要代码的分析结果

#### 团队分享
- **知识分享**: 将有价值的分析结果分享给团队成员
- **标准建立**: 基于分析结果建立团队的编码标准
- **培训材料**: 将分析结果用作新员工培训材料
- **最佳实践**: 提炼和推广代码中的最佳实践

### 质量保证建议

#### 验证检查
- **交叉验证**: 通过多种方式验证分析的准确性
- **实际测试**: 通过运行代码验证分析的正确性
- **专家评审**: 请有经验的开发者评审分析结果
- **反馈收集**: 收集使用者的反馈和建议

#### 持续改进
- **效果跟踪**: 跟踪分析结果的实际应用效果
- **方法优化**: 根据使用反馈优化分析方法
- **知识更新**: 及时更新技术知识和分析能力
- **工具升级**: 持续升级和改进分析工具和流程

# 命令执行限制说明

**重要提醒**: 此命令专注于代码的理解和分析，不涉及代码的修改、重构或实际问题的解决。如需要以下服务，请使用对应的专业命令：

- **代码实现**: 使用 `godot-game-developer` 命令
- **代码审查**: 使用 `godot-code-reviewer` 命令
- **问题调试**: 使用 `godot-debug` 命令
- **性能优化**: 使用 `godot-code-reviewer` 命令进行性能分析
- **架构设计**: 使用 `godot-architect` 命令