---
name: godot-gen-code
description: 采用人机协作方式完成Godot项目编码任务，通过智能任务分解确保质量。该命令专注于高质量的代码生成，结合需求分析、架构设计、代码实现和测试验证的全流程，确保生成的代码符合Godot最佳实践和项目需求。
argument-hint: [编码任务描述]
---

# 命令参数说明

- **编码任务描述** (必需): 详细描述需要实现的编码任务，包含以下要素：
  - **功能需求**: 具体要实现的功能和特性
  - **技术要求**: 使用的Godot版本、目标平台、性能要求
  - **设计约束**: 代码风格、架构模式、现有集成要求
  - **验收标准**: 功能完成的验收条件和测试要求
  - **优先级**: 功能实现的优先级和紧急程度

# 执行步骤

**当前编码目标**: $ARGUMENTS

## 第一阶段：需求分析与架构设计
### 工具使用：sequential-thinking + memory + filesystem

1. **需求解析与分析** (使用 sequential-thinking 工具)
   - 深入分析 **$1** 的功能需求和技术要求
   - 识别关键的技术挑战和实现难点
   - 分析与现有系统的集成要求
   - 评估实现的复杂度和工作量

2. **技术方案设计** (使用 memory 工具)
   - 为 **$1** 查询相关的Godot最佳实践和设计模式
   - 分析合适的技术实现方案
   - 评估不同方案的优缺点和适用性
   - 确定最佳的架构设计和实现策略

3. **任务分解与规划** (使用 sequential-thinking 工具)
   - 将 **$1** 分解为可管理的子任务
   - 制定详细的实施计划和里程碑
   - 确定各任务的依赖关系和执行顺序
   - 设计代码组织结构和文件架构

## 第二阶段：详细设计与代码规划
### 工具使用：memory + filesystem + sequential-thinking

1. **代码架构设计** (使用 memory 工具)
   - 为 **$1** 设计场景结构和节点层次
   - 规划脚本组织和类结构设计
   - 确定数据结构和算法选择
   - 设计接口定义和模块交互

2. **实现策略制定** (使用 filesystem 工具)
   - 分析现有项目结构和代码风格
   - 确定 **$1** 新代码的集成方式
   - 规划文件组织和命名规范
   - 制定代码复用和扩展策略

3. **质量标准定义** (使用 sequential-thinking 工具)
   - 确定 **$1** 的代码质量标准和规范要求
   - 设计测试策略和验证方法
   - 制定性能指标和优化目标
   - 确定文档和注释的详细程度

## 第三阶段：代码生成与实现
### 工具使用：godot-game-developer + filesystem

1. **核心代码生成** (使用 godot-game-developer Agent)
   - 为 **$1** 生成主要的功能实现代码
   - 创建场景文件和节点结构
   - 实现核心的游戏逻辑和算法
   - 集成必要的Godot引擎功能

2. **配套代码开发** (使用 filesystem 工具)
   - 为 **$1** 创建辅助脚本和工具类
   - 实现数据管理和资源加载
   - 添加错误处理和异常管理
   - 实现用户界面和交互功能

3. **代码集成与优化** (使用 godot-game-developer Agent)
   - 为 **$1** 集成新生成的代码到现有项目
   - 优化代码性能和资源使用
   - 确保代码风格和规范的一致性
   - 实现代码的模块化和可扩展性

## 第四阶段：测试验证与质量保证
### 工具使用：godot + godot-code-reviewer + sequential-thinking

1. **功能测试验证** (使用 godot 工具)
   - 运行项目并测试 **$1** 的功能
   - 验证功能需求的完整实现
   - 检查与其他模块的集成效果
   - 收集运行时信息和性能数据

2. **代码质量审查** (使用 godot-code-reviewer Agent)
   - 为 **$1** 进行全面的代码质量审查
   - 检查代码规范和最佳实践
   - 识别潜在的问题和改进点
   - 验证代码的安全性和稳定性

3. **性能优化与完善** (使用 sequential-thinking 工具)
   - 分析 **$1** 的性能瓶颈和优化机会
   - 完善错误处理和边界条件
   - 优化用户体验和交互设计
   - 确保代码的可维护性和扩展性

# Agent 与 MCP 工具指定

## 主要执行 Agent

### godot-game-developer (主导 Agent)
- **使用阶段**: 第三阶段代码实现和集成
- **核心职责**: 专业Godot代码实现、功能开发、性能优化
- **专业能力**: GDScript编程、场景设计、资源管理、游戏机制实现
- **主要工具**:
  - `godot`: 场景创建、节点管理、项目运行测试
  - `filesystem`: 代码文件创建、编辑、组织
  - `memory`: 查询Godot编程知识和最佳实践

### godot-architect (架构设计 Agent)
- **使用阶段**: 第一阶段和第二阶段架构规划
- **核心职责**: 系统架构设计、代码结构规划、技术方案选择
- **专业能力**: SOLID原则应用、模块化设计、系统架构优化
- **主要工具**:
  - `sequential-thinking`: 架构决策分析、设计权衡评估
  - `memory`: 查询设计模式和架构最佳实践
  - `filesystem`: 分析现有项目结构和代码组织

### godot-code-reviewer (质量保证 Agent)
- **使用阶段**: 第四阶段代码审查和质量验证
- **核心职责**: 代码质量检查、性能分析、错误识别
- **专业能力**: 代码异味识别、性能瓶颈分析、最佳实践验证
- **主要工具**:
  - `sequential-thinking`: 代码质量分析、问题诊断
  - `godot`: 运行测试、性能监控、调试输出分析
  - `memory`: 查询代码质量标准和审查规范

## MCP 工具使用策略

### 1. godot 工具
- **使用时机**: 第三阶段场景创建、第四阶段测试验证
- **具体用途**:
  - `get_project_info`: 获取项目信息用于架构设计
  - `create_scene`: 创建新的场景文件和结构
  - `add_node`: 向场景添加必要的节点和组件
  - `load_sprite`: 加载和管理游戏资源和素材
  - `run_project`: 运行项目进行功能测试
  - `get_debug_output`: 监控调试信息和错误状态
- **操作策略**: 结合项目需求创建合适的场景结构

### 2. filesystem 工具
- **使用时机**: 第一阶段需求分析、第三阶段代码生成、第四阶段文档整理
- **具体用途**:
  - `read_multiple_files`: 分析现有代码结构和实现方式
  - `write_file`: 创建新的脚本文件和配置
  - `edit_file`: 修改现有代码和集成新功能
  - `create_directory`: 创建合适的文件夹结构
  - `directory_tree`: 分析项目的整体文件组织
- **操作策略**: 遵循项目的文件组织规范和命名约定

### 3. sequential-thinking 工具
- **使用时机**: 第一阶段需求分析、第二阶段设计决策、第四阶段质量优化
- **具体用途**:
  - 分解复杂的编码任务为可管理步骤
  - 分析技术方案的可行性和优缺点
  - 设计合理的代码架构和模块划分
  - 制定全面的测试和验证策略
- **思考深度**: 根据任务复杂度调整分析深度和广度

### 4. memory 工具
- **使用时机**: 全程知识支持和最佳实践查询
- **具体用途**:
  - 存储项目的特定需求和约束条件
  - 查询Godot编程的最佳实践和设计模式
  - 记录重要的技术决策和实现方案
  - 建立代码质量和标准的知识关联
- **记忆策略**: 为每个项目建立独立的实现知识库

# 交付件说明

## 主要交付物清单

### 1. 需求分析与设计方案 (Requirements & Design Analysis)
**文件名格式**: `design_analysis_[功能模块]_[日期].md`

**包含内容**:
- 详细的需求分析和技术要求
- 多种技术方案的比较和选择
- 系统架构设计和模块划分
- 实施计划和风险评估

**文档结构**:
```markdown
# 需求分析与设计方案：[功能模块]

## 1. 需求分析
### 1.1 功能需求
### 1.2 技术要求
### 1.3 约束条件
### 1.4 验收标准

## 2. 技术方案设计
### 2.1 方案比较
### 2.2 最优方案选择
### 2.3 技术实现策略
### 2.4 风险评估

## 3. 系统架构设计
### 3.1 整体架构
### 3.2 模块划分
### 3.3 接口设计
### 3.4 数据流设计
```

### 2. 详细实现规范 (Detailed Implementation Specification)
**文件名格式**: `implementation_spec_[功能模块]_[日期].md`

**包含内容**:
- 详细的代码实现规范和标准
- 文件结构和命名约定
- 代码组织和模块设计
- 性能要求和质量标准

**文档结构**:
```markdown
# 详细实现规范：[功能模块]

## 1. 代码规范
### 1.1 编码标准
### 1.2 命名约定
### 1.3 文档要求
### 1.4 注释规范

## 2. 文件结构设计
### 2.1 目录组织
### 2.2 文件命名
### 2.3 模块划分
### 2.4 依赖关系

## 3. 实现标准
### 3.1 性能要求
### 3.2 错误处理
### 3.3 安全考虑
### 3.4 扩展性设计
```

### 3. 完整代码实现 (Complete Code Implementation)
**交付内容**: 所有必需的脚本文件、场景文件和资源文件

**包含文件**:
- **脚本文件** (.gd): 主要功能实现代码
- **场景文件** (.tscn): 场景结构和节点配置
- **配置文件** (.json/.cfg): 相关配置和设置
- **资源文件**: 必要的素材和资源引用

**代码质量标准**:
- 符合Godot编码规范和最佳实践
- 包含完整的错误处理和异常管理
- 提供详细的代码注释和文档
- 实现模块化和可扩展的设计

### 4. 测试验证报告 (Testing & Validation Report)
**文件名格式**: `test_report_[功能模块]_[日期].md`

**包含内容**:
- 功能测试的完整结果
- 性能测试数据和基准对比
- 集成测试和兼容性验证
- 问题修复和优化记录

**文档结构**:
```markdown
# 测试验证报告：[功能模块]

## 1. 功能测试结果
### 1.1 核心功能验证
### 1.2 边界条件测试
### 1.3 异常处理测试
### 1.4 用户体验测试

## 2. 性能测试数据
### 2.1 运行时性能
### 2.2 内存使用情况
### 2.3 资源加载效率
### 2.4 平台兼容性

## 3. 集成测试验证
### 3.1 模块间交互
### 3.2 数据同步
### 3.3 事件处理
### 3.4 状态管理

## 4. 问题修复记录
### 4.1 发现的问题
### 4.2 修复方案
### 4.3 验证结果
### 4.4 优化建议
```

### 5. 技术文档与使用指南 (Technical Documentation & Usage Guide)
**文件名格式**: `tech_documentation_[功能模块]_[日期].md`

**包含内容**:
- 功能的技术实现说明
- API文档和使用示例
- 配置和部署指南
- 维护和扩展建议

**文档结构**:
```markdown
# 技术文档与使用指南：[功能模块]

## 1. 技术实现说明
### 1.1 整体架构
### 1.2 核心算法
### 1.3 关键技术点
### 1.4 设计决策说明

## 2. API文档
### 2.1 公共接口
### 2.2 参数说明
### 2.3 返回值定义
### 2.4 使用示例

## 3. 配置与部署
### 3.1 配置参数
### 3.2 环境要求
### 3.3 部署步骤
### 3.4 故障排除

## 4. 维护与扩展
### 4.1 维护指南
### 4.2 扩展接口
### 4.3 版本兼容性
### 4.4 最佳实践
```

## 实时协作支持

### 编码进度跟踪
**实时输出**: 在对话中提供实时的编码进度和状态更新

**包含内容**:
- 当前实现阶段和完成进度
- 遇到的技术问题和解决方案
- 代码质量检查结果和改进建议
- 下一步实施计划和优先级

**输出格式**:
```markdown
## 📊 编码进度报告
**当前阶段**: [具体实现阶段]
**完成度**: [百分比]%
**预计完成时间**: [时间估算]

## 🔧 技术实现状态
- **已完成**: [已完成的功能模块]
- **进行中**: [正在实现的功能]
- **待开始**: [待实现的功能列表]

## ⚠️ 问题与解决方案
- **技术挑战**: [遇到的技术难点]
- **解决方案**: [采用的解决策略]
- **影响评估**: [对进度和质量的影响]

## 🎯 下一步计划
1. [具体的下一步实施内容]
2. [需要的资源或信息]
3. [预期完成时间和标准]
```

# 约束与限制条件

## 实现范围约束

### 功能复杂度约束
- **复杂度控制**: 单次实现的复杂度控制在合理范围内
- **模块化设计**: 优先采用模块化的实现方式
- **可测试性**: 确保实现的功能具有可测试性
- **可维护性**: 保证代码的可读性和可维护性

### 技术约束条件
- **Godot版本**: 基于指定的Godot版本进行实现
- **平台兼容**: 考虑目标平台的特性和限制
- **性能要求**: 满足指定的性能指标和要求
- **资源限制**: 在给定的资源约束下进行实现

### 质量标准约束
- **代码规范**: 严格遵循Godot代码规范和最佳实践
- **错误处理**: 实现完整的错误处理和异常管理
- **文档完整性**: 提供完整的代码文档和使用说明
- **测试覆盖**: 确保充分的测试覆盖和验证

## 集成约束条件

### 现有系统集成
- **架构兼容**: 新功能必须与现有架构兼容
- **数据格式**: 遵循现有的数据格式和通信协议
- **接口规范**: 使用统一的接口规范和调用方式
- **风格一致**: 保持与现有代码的一致性

### 依赖管理约束
- **外部依赖**: 控制外部依赖的数量和复杂性
- **版本控制**: 管理依赖库的版本兼容性
- **许可证合规**: 确保所有依赖的许可证兼容性
- **安全考虑**: 评估依赖库的安全性和可靠性

### 扩展性约束
- **接口设计**: 设计可扩展的接口和架构
- **配置管理**: 实现灵活的配置和参数管理
- **插件支持**: 考虑未来插件和扩展的支持
- **版本兼容**: 保证向后兼容性和平滑升级

## 使用约束条件

### 需求明确性约束
- **需求完整**: 用户必须提供完整和明确的功能需求
- **技术规范**: 提供详细的技术要求和约束条件
- **验收标准**: 明确定义功能完成的验收标准
- **优先级**: 清晰指定功能实现的优先级顺序

### 协作过程约束
- **反馈及时**: 用户需要及时提供反馈和确认
- **决策参与**: 重要技术决策需要用户参与确认
- **测试验证**: 用户需要参与最终的测试和验收
- **文档确认**: 技术文档需要用户确认和认可

### 应用责任约束
- **部署决策**: 代码的实际部署和应用由用户决策
- **风险承担**: 代码应用的风险和后果由用户承担
- **维护责任**: 代码的长期维护和优化由用户负责
- **升级管理**: 版本升级和兼容性管理由用户负责

## 伦理约束条件

### 知识产权约束
- **原创性**: 确保生成的代码具有原创性
- **版权尊重**: 尊重现有的代码版权和知识产权
- **许可合规**: 遵循相关的开源许可证要求
- **商业机密**: 保护用户的商业机密和敏感信息

### 专业责任约束
- **质量承诺**: 对生成的代码质量承担专业责任
- **能力透明**: 透明地展示技术能力和限制
- **持续改进**: 基于反馈持续改进代码生成能力
- **安全考虑**: 优先考虑代码的安全性和稳定性

# 使用场景与最佳实践

## 适用场景

### 新功能开发
- **核心功能**: 游戏核心机制和玩法功能
- **系统功能**: 存档系统、设置界面、成就系统
- **界面功能**: UI菜单、对话系统、教程系统
- **工具功能**: 编辑器工具、调试工具、性能分析工具

### 功能扩展
- **现有增强**: 在现有功能基础上增加新特性
- **性能优化**: 优化现有代码的性能和效率
- **平台适配**: 将功能适配到新的平台或设备
- **版本升级**: 升级代码以支持新的Godot版本

### 代码重构
- **架构改进**: 改进代码架构和设计模式
- **模块化**: 将单体代码重构为模块化结构
- **标准化**: 将代码标准化为最佳实践
- **可维护性**: 提高代码的可维护性和可扩展性

### 原型开发
- **概念验证**: 快速实现功能概念进行验证
- **技术预研**: 预研新技术的可行性和实现方式
- **演示原型**: 创建用于演示的原型功能
- **实验项目**: 开发实验性的新功能和想法

## 不适用场景

### 非编码任务
- **设计决策**: 游戏设计和创意决策
- **美术资源**: 图像、音效、动画等资源制作
- **市场推广**: 营销策略和推广活动
- **项目管理**: 项目管理和团队协调

### 复杂系统集成
- **第三方集成**: 复杂的第三方服务集成
- **数据库设计**: 大型数据库设计和优化
- **网络架构**: 复杂的网络架构和服务器配置
- **硬件集成**: 硬件设备和传感器的集成

### 法律合规任务
- **版权申请**: 代码版权和法律保护
- **专利申请**: 技术专利的申请和保护
- **合规审查**: 法律法规的合规性审查
- **风险评估**: 法律风险的评估和防控

## 最佳实践指南

### 需求描述优化

#### 功能需求明确化
- **具体描述**: 使用具体和明确的语言描述功能需求
- **用户场景**: 描述具体的使用场景和用户故事
- **验收条件**: 明确定义功能完成的验收条件和标准
- **边界条件**: 说明功能的边界和限制条件

#### 技术要求具体化
- **平台要求**: 明确目标平台和技术环境
- **性能指标**: 提供具体的性能指标和要求
- **集成要求**: 说明与现有系统的集成要求
- **兼容性**: 指定版本兼容性和向后支持要求

### 实施过程优化

#### 迭代开发策略
- **MVP优先**: 优先实现最小可用版本(MVP)
- **增量开发**: 采用增量和迭代的开发方式
- **快速验证**: 快速实现和验证核心功能
- **持续改进**: 基于反馈持续改进和完善

#### 质量保证策略
- **代码审查**: 进行系统的代码审查和质量检查
- **自动测试**: 实现自动化的测试和验证流程
- **性能监控**: 持续监控性能指标和优化效果
- **文档同步**: 保持代码和文档的同步更新

### 协作沟通优化

#### 反馈机制
- **及时反馈**: 提供及时的实现进度和问题反馈
- **明确确认**: 对重要的技术决策寻求明确确认
- **问题报告**: 清晰地报告遇到的问题和解决方案
- **改进建议**: 主动提供改进建议和优化方案

#### 期望管理
- **能力透明**: 透明地沟通技术能力和限制
- **时间估算**: 提供现实的完成时间和工作量估算
- **风险提示**: 及时提示潜在的风险和问题
- **质量承诺**: 对代码质量做出明确的承诺

# 命令执行限制说明

**重要提醒**: 此命令专注于高质量的代码生成和实现，不涉及游戏设计、美术制作或商业决策。如需要以下服务，请使用对应的专业命令：

- **游戏设计**: 使用 `godot-game-design` 命令进行游戏概念和机制设计
- **架构设计**: 使用 `godot-architect` 命令进行系统架构设计
- **代码审查**: 使用 `godot-code-reviewer` 命令进行代码质量审查
- **文档生成**: 使用 `godot-gen-doc` 命令生成技术文档
- **问题调试**: 使用 `godot-debug` 命令解决技术问题和错误