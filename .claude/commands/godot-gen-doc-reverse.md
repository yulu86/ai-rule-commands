---
name: godot-gen-doc-reverse
description: 通过分析现有Godot项目代码，逆向推导生成相应的游戏设计文档。该命令专门用于代码重构、文档补全和项目交接，通过深度分析代码结构、功能实现和设计模式，反向推导出完整的设计理念和技术架构文档。
argument-hint: [分析主题]
---

# 命令参数说明

- **分析主题** (必需): 指定文档生成的主题和范围，可以是以下形式：
  - **整体项目**: 分析整个项目的完整设计文档
  - **特定模块**: 如 "战斗系统"、"存档系统"、"UI系统" 等
  - **功能范围**: 如 "玩家控制"、"敌人AI"、"关卡机制" 等
  - **技术架构**: 如 "场景架构"、"脚本组织"、"资源管理" 等

# 执行步骤

## 第一阶段：代码结构深度分析
### 工具使用：filesystem + godot + sequential-thinking

1. **项目整体扫描** (使用 filesystem 工具)
   - 递归分析项目的完整文件结构
   - 识别场景文件、脚本文件和资源文件
   - 分析项目的组织架构和模块划分
   - 收集项目配置和元数据信息

2. **场景结构解析** (使用 godot 工具)
   - 获取项目的场景结构和节点层次
   - 分析场景间的关联和继承关系
   - 识别主要的场景类型和功能分类
   - 理解场景的组织逻辑和设计思路

3. **代码架构分析** (使用 sequential-thinking 工具)
   - 分析脚本文件的组织结构和依赖关系
   - 识别核心类和功能模块
   - 理解代码的设计模式和编程范式
   - 评估架构的合理性和扩展性

## 第二阶段：功能实现逆向推导
### 工具使用：godot-game-developer + sequential-thinking + memory

1. **核心机制识别** (使用 godot-game-developer Agent)
   - 识别游戏的核心玩法机制
   - 分析玩家交互和控制系统
   - 理解游戏的规则和胜负条件
   - 推导游戏循环和状态管理

2. **系统功能解析** (使用 sequential-thinking 工具)
   - 分析各个系统模块的功能实现
   - 理解系统间的交互和数据流
   - 识别关键的算法和数据结构
   - 评估系统的完整性和一致性

3. **设计模式推导** (使用 memory 工具)
   - 识别代码中使用的设计模式
   - 分析架构决策的设计意图
   - 理解技术选型的理由和优势
   - 推导原始的设计思路和理念

## 第三阶段：用户体验与交互分析
### 工具使用：godot-code-reviewer + sequential-thinking

1. **用户界面分析** (使用 godot-code-reviewer Agent)
   - 分析UI布局和交互设计
   - 理解用户操作流程和体验路径
   - 识别反馈系统和响应机制
   - 评估界面设计的可用性和一致性

2. **游戏体验推导** (使用 sequential-thinking 工具)
   - 分析游戏的节奏和难度设计
   - 理解玩家的成长和进程系统
   - 识别奖励机制和动机设计
   - 推导目标受众和体验定位

3. **技术实现分析** (使用 sequential-thinking 工具)
   - 分析性能优化和技术实现
   - 理解跨平台兼容性考虑
   - 识别扩展性和维护性设计
   - 评估技术架构的成熟度

## 第四阶段：设计文档生成
### 工具使用：design-doc-writer + filesystem + memory

1. **游戏设计文档生成** (使用 design-doc-writer Agent)
   - 生成完整的游戏设计文档(GDD)
   - 包含游戏概述、核心机制、系统设计
   - 添加用户体验和交互设计说明
   - 整理技术实现和架构说明

2. **技术文档整理** (使用 filesystem 工具)
   - 生成技术架构文档和API说明
   - 整理代码规范和开发指南
   - 创建部署和维护文档
   - 生成项目交接和培训材料

3. **知识库建立** (使用 memory 工具)
   - 建立项目的技术知识库
   - 整理设计决策和最佳实践
   - 记录问题解决方案和经验
   - 创建可复用的设计模式库

# Agent 与 MCP 工具指定

## 主要执行 Agent

### godot-architect (主导 Agent)
- **使用阶段**: 第一阶段和第二阶段
- **核心职责**: 架构分析、设计模式识别、技术推导
- **专业能力**: 系统架构分析、设计模式识别、技术方案评估
- **主要工具**:
  - `godot`: 项目结构分析、场景信息获取
  - `filesystem`: 代码文件扫描和分析
  - `sequential-thinking`: 复杂架构分析和设计推理

### godot-game-developer (功能分析 Agent)
- **使用阶段**: 第二阶段功能识别
- **核心职责**: 游戏功能分析、机制推导、实现理解
- **专业能力**: 游戏机制分析、系统功能解析、代码实现理解
- **主要工具**:
  - `sequential-thinking`: 功能逻辑分析和机制推导
  - `memory`: 游戏设计知识和模式查询
  - `filesystem`: 相关代码文件深入分析

### godot-code-reviewer (质量分析 Agent)
- **使用阶段**: 第三阶段用户体验分析
- **核心职责**: 代码质量分析、用户体验评估、技术评估
- **专业能力**: 代码质量检查、用户交互分析、技术实现评估
- **主要工具**:
  - `sequential-thinking`: 用户体验和技术质量分析
  - `godot`: 实际运行测试和观察
  - `memory`: 用户体验和代码质量标准查询

### design-doc-writer (文档生成 Agent)
- **使用阶段**: 第四阶段文档整理和生成
- **核心职责**: 文档结构化、内容组织、标准化输出
- **专业能力**: 技术文档撰写、GDD标准化、知识整理
- **主要工具**:
  - `filesystem`: 文档创建和格式化
  - `memory`: 文档模板和标准查询
  - `sequential-thinking`: 文档结构设计和内容组织

## MCP 工具使用策略

### 1. filesystem 工具
- **使用时机**: 第一阶段项目扫描、第四阶段文档生成
- **具体用途**:
  - `directory_tree`: 获取项目的完整目录结构
  - `list_directory_with_sizes`: 分析项目规模和文件分布
  - `search_files`: 查找特定类型和功能的文件
  - `read_multiple_files`: 批量读取相关代码文件进行分析
  - `write_file`: 创建生成的文档和报告
- **操作策略**: 系统化地扫描和分析项目文件

### 2. godot 工具
- **使用时机**: 第一阶段场景分析、第三阶段功能测试
- **具体用途**:
  - `get_project_info`: 获取项目基本信息和配置
  - `list_projects`: 了解项目结构和组织方式
  - `run_project`: 运行项目观察实际效果和功能
  - `get_debug_output`: 监控运行时信息和状态
- **操作策略**: 通过实际运行验证代码分析的结果

### 3. sequential-thinking 工具
- **使用时机**: 全程的深度分析和推理过程
- **具体用途**:
  - 逐步分析复杂的代码结构和设计思路
  - 推导原始的设计意图和技术决策
  - 分析系统功能间的交互和依赖关系
  - 评估设计的合理性和改进空间
- **思考深度**: 根据分析对象的复杂度调整推理深度

### 4. memory 工具
- **使用时机**: 全程的知识支持和模式识别
- **具体用途**:
  - 识别和匹配常见的设计模式和架构
  - 查询游戏设计知识和最佳实践
  - 存储分析过程中的重要发现和结论
  - 建立项目特定的设计知识库
- **记忆策略**: 为每个设计模式建立独立的知识实体

# 交付件说明

## 主要交付物清单

### 1. 项目总体分析报告 (Project Analysis Report)
**文件名格式**: `project_analysis_[项目名]_[日期].md`

**包含内容**:
- 项目的基本信息和技术特征
- 整体架构和模块划分分析
- 代码质量和设计模式评估
- 技术栈和实现方式总结

**文档结构**:
```markdown
# 项目总体分析报告：[项目名称]

## 1. 项目基本信息
### 1.1 技术规格
### 1.2 项目规模
### 1.3 开发背景
### 1.4 技术栈分析

## 2. 整体架构分析
### 2.1 架构模式
### 2.2 模块划分
### 2.3 依赖关系
### 2.4 设计原则

## 3. 代码质量评估
### 3.1 代码规范
### 3.2 设计模式
### 3.3 可维护性
### 3.4 扩展性分析

## 4. 技术特征总结
### 4.1 核心技术
### 4.2 实现亮点
### 4.3 技术债务
### 4.4 改进建议
```

### 2. 逆向生成游戏设计文档 (Reverse-Generated GDD)
**文件名格式**: `generated_gdd_[项目名]_[版本]_[日期].md`

**包含内容**:
- 完整的游戏设计概念和机制说明
- 核心玩法和系统设计详细描述
- 用户体验和交互设计规范
- 技术实现和架构设计文档

**文档结构**:
```markdown
# 逆向生成游戏设计文档：[项目名称]

## 1. 游戏概述
### 1.1 游戏概念推导
### 1.2 核心玩法分析
### 1.3 目标受众定位
### 1.4 独特卖点识别

## 2. 核心机制设计
### 2.1 核心玩法循环
### 2.2 控制系统分析
### 2.3 规则和机制推导
### 2.4 平衡性设计评估

## 3. 系统功能设计
### 3.1 进程系统
### 3.2 战斗/挑战系统
### 3.3 经济/奖励系统
### 3.4 社交/多玩家系统

## 4. 用户体验设计
### 4.1 UI/UX分析
### 4.2 交互流程推导
### 4.3 反馈系统设计
### 4.4 新手引导分析

## 5. 技术架构设计
### 5.1 系统架构推导
### 5.2 关键技术分析
### 5.3 性能优化策略
### 5.4 扩展性设计
```

### 3. 技术架构文档 (Technical Architecture Documentation)
**文件名格式**: `tech_architecture_[项目名]_[日期].md`

**包含内容**:
- 详细的技术架构和设计决策说明
- 模块划分和接口定义
- 数据结构和算法分析
- 性能优化和扩展性考虑

**文档结构**:
```markdown
# 技术架构文档：[项目名称]

## 1. 架构概述
### 1.1 整体架构推导
### 1.2 设计原则分析
### 1.3 技术选型理由
### 1.4 架构优势评估

## 2. 模块架构设计
### 2.1 模块划分策略
### 2.2 接口设计推导
### 2.3 数据流分析
### 2.4 通信机制设计

## 3. 关键技术分析
### 3.1 核心算法推导
### 3.2 数据结构设计
### 3.3 性能优化技术
### 3.4 安全性考虑

## 4. 实现细节
### 4.1 关键类设计
### 4.2 重要函数分析
### 4.3 资源管理策略
### 4.4 错误处理机制
```

### 4. 代码实现规范文档 (Code Implementation Guidelines)
**文件名格式**: `code_guidelines_[项目名]_[日期].md`

**包含内容**:
- 代码风格和编程规范
- 开发流程和最佳实践
- 测试策略和质量保证
- 维护和扩展指南

**文档结构**:
```markdown
# 代码实现规范文档：[项目名称]

## 1. 编码规范
### 1.1 代码风格分析
### 1.2 命名约定推导
### 1.3 注释和文档标准
### 1.4 错误处理规范

## 2. 开发流程
### 2.1 开发流程推导
### 2.2 代码审查标准
### 2.3 测试策略分析
### 2.4 部署流程设计

## 3. 最佳实践
### 3.1 设计模式应用
### 3.2 性能优化技巧
### 3.3 安全编程实践
### 3.4 调试和故障排除

## 4. 维护指南
### 4.1 维护策略设计
### 4.2 扩展指南制定
### 4.3 版本管理规范
### 4.4 知识传承计划
```

### 5. 项目交接文档 (Project Handover Documentation)
**文件名格式**: `handover_document_[项目名]_[日期].md`

**包含内容**:
- 项目背景和目标说明
- 技术架构和实现要点
- 关键人员和联系方式
- 维护和扩展建议

**文档结构**:
```markdown
# 项目交接文档：[项目名称]

## 1. 项目背景
### 1.1 项目目标和愿景
### 1.2 开发历程和里程碑
### 1.3 当前状态和成果
### 1.4 未来发展规划

## 2. 技术交接要点
### 2.1 核心技术架构
### 2.2 关键实现逻辑
### 2.3 重要配置和设置
### 2.4 常见问题和解决方案

## 3. 团队和资源
### 3.1 关键人员职责
### 3.2 外部依赖和接口
### 3.3 开发环境和工具
### 3.4 文档和知识库

## 4. 维护和扩展
### 4.1 维护计划和流程
### 4.2 扩展点和接口
### 4.3 风险和注意事项
### 4.4 联系和支持信息
```

## 实时分析进度

### 分析状态跟踪
**实时输出**: 在对话中提供实时的分析进度和发现

**包含内容**:
- 当前分析阶段和完成进度
- 重要发现和设计洞察
- 遇到的分析挑战和解决方案
- 下一步分析计划和重点

**输出格式**:
```markdown
## 🔍 逆向分析进度报告
**当前阶段**: [具体分析阶段]
**完成度**: [百分比]%
**分析范围**: [当前分析的对象和范围]

## 💡 重要发现
- **架构模式**: [识别出的架构模式]
- **设计思路**: [推导出的设计思路]
- **技术特点**: [发现的技术特点和亮点]
- **设计决策**: [重要设计决策的推理]

## ⚠️ 分析挑战
- **复杂度**: [当前分析的复杂程度]
- **信息缺失**: [缺失的信息和推断]
- **不确定性**: [分析中的不确定因素]
- **验证需求**: [需要进一步验证的内容]

## 🎯 下一步计划
1. [具体的下一步分析内容]
2. [重点关注的设计特征]
3. [需要深入分析的技术点]
4. [文档生成的优先顺序]
```

# 约束与限制条件

## 分析范围约束

### 代码完整性约束
- **代码质量**: 分析结果的准确性依赖于代码质量
- **注释文档**: 缺少注释会影响设计意图的理解
- **代码一致性**: 代码风格不一致会增加分析难度
- **实现完整度**: 未完成的实现会影响分析的完整性

### 复杂度约束
- **项目规模**: 大型项目的分析需要更多时间和资源
- **模块耦合**: 高耦合的代码难以准确分离功能模块
- **动态行为**: 复杂的运行时行为难以通过静态分析完全理解
- **外部依赖**: 对外部系统的依赖影响分析的完整性

### 推理准确性约束
- **设计意图**: 逆向推导的设计意图可能存在偏差
- **功能理解**: 对复杂功能的理解可能不够深入
- **用户体验**: 用户体验的推导基于代码分析，可能不够准确
- **性能特征**: 性能特征的推导需要实际运行验证

## 技术约束条件

### 静态分析限制
- **运行时信息**: 静态分析无法获取完整的运行时信息
- **数据流分析**: 复杂的数据流分析可能不够准确
- **性能特征**: 性能特征的识别存在局限性
- **用户行为**: 用户行为和交互模式难以静态分析

### 推理能力约束
- **创造性**: 无法创造代码中不存在的设计元素
- **业务逻辑**: 复杂的业务逻辑理解可能存在偏差
- **市场定位**: 市场定位和商业策略的推导准确性有限
- **用户研究**: 缺少实际用户数据和研究支持

### 文档生成约束
- **标准化**: 生成的文档遵循标准化的格式和结构
- **完整性**: 文档完整性依赖于分析的深度和广度
- **时效性**: 文档反映的是分析时的项目状态
- **维护性**: 文档需要定期更新以反映项目变化

## 使用约束条件

### 分析前提约束
- **代码访问**: 需要完整的项目代码访问权限
- **项目结构**: 项目需要有一定的组织结构和规范性
- **技术栈**: 支持主流的Godot技术栈和开发模式
- **文档需求**: 明确文档生成目标和受众需求

### 结果应用约束
- **验证责任**: 用户需要验证生成文档的准确性
- **更新维护**: 项目变更时需要及时更新文档
- **专业判断**: 需要专业人员对分析结果进行判断
- **补充完善**: 可能需要补充实际的设计信息和用户反馈

### 质量保证约束
- **交叉验证**: 建议通过多种方式验证分析结果
- **团队参与**: 鼓励团队成员参与文档的完善和验证
- **持续改进**: 基于使用反馈持续改进分析质量
- **专家审查**: 建议邀请专家审查重要的技术文档

## 伦理约束条件

### 知识产权约束
- **版权保护**: 尊重原项目的版权和知识产权
- **机密信息**: 保护项目中的商业机密和敏感信息
- **使用授权**: 确保有权限分析和生成相关文档
- **分发控制**: 控制生成文档的分发和使用范围

### 专业责任约束
- **准确性**: 对分析结果的准确性承担专业责任
- **透明度**: 透明地说明分析方法的能力和限制
- **客观性**: 保持客观中立的分析态度
- **持续学习**: 持续学习改进分析技术和方法

# 使用场景与最佳实践

## 适用场景

### 项目交接场景
- **团队变更**: 开发团队人员变更时的知识交接
- **项目转让**: 项目转让给其他团队或公司
- **外包交接**: 外包开发完成后的内部交接
- **人员离职**: 关键开发人员离职时的知识保留

### 文档补全场景
- **文档缺失**: 原有设计文档缺失或不完整
- **文档过时**: 现有文档与实际代码不一致
- **标准升级**: 需要将文档升级到新的标准格式
- **多语言**: 需要生成不同语言版本的文档

### 代码重构场景
- **架构重构**: 在进行大型架构重构前理解现有设计
- **模块重用**: 提取可重用的模块和设计模式
- **技术迁移**: 迁移到新技术平台前的设计分析
- **性能优化**: 理解设计逻辑以进行有效的性能优化

### 学习研究场景
- **技术学习**: 通过分析优秀项目学习设计技巧
- **模式研究**: 研究特定设计模式的实际应用
- **架构学习**: 学习复杂系统的架构设计思路
- **最佳实践**: 提炼和总结项目中的最佳实践

## 不适用场景

### 设计创作场景
- **新项目设计**: 无法为不存在的新项目生成设计文档
- **创意构思**: 无法替代游戏设计师的创意构思工作
- **市场分析**: 无法进行深入的市场分析和用户研究
- **商业规划**: 无法制定商业策略和产品规划

### 运行时调试
- **Bug修复**: 不是主要的调试和Bug修复工具
- **性能分析**: 无法替代专业的性能分析工具
- **安全审计**: 不是专业的安全漏洞分析工具
- **兼容性测试**: 无法替代完整的兼容性测试

### 法律合规场景
- **版权评估**: 无法进行版权和法律风险评估
- **合规审查**: 不能作为正式的合规性审查工具
- **专利分析**: 无法进行专利侵权分析
- **法律咨询**: 不能提供专业的法律咨询意见

## 最佳实践指南

### 分析准备优化

#### 项目准备
- **代码完整**: 确保项目代码的完整性和可编译性
- **环境一致**: 在一致的运行环境中进行分析
- **版本控制**: 使用稳定的版本进行分析
- **权限明确**: 确保有分析所需的完整权限

#### 目标明确
- **分析范围**: 明确界定分析的范围和重点
- **文档目标**: 明确文档的目标受众和使用目的
- **详细程度**: 确定文档的详细程度和深度
- **时间规划**: 合理规划分析的时间和资源

### 分析过程优化

#### 系统化方法
- **分层分析**: 采用分层和模块化的分析方法
- **逐步深入**: 从宏观到微观逐步深入分析
- **多角度验证**: 从多个角度验证分析结果
- **记录推理**: 详细记录重要的推理过程和结论

#### 质量控制
- **交叉验证**: 通过不同方式验证重要发现
- **专家咨询**: 在关键问题上寻求专家意见
- **迭代完善**: 通过迭代不断完善分析结果
- **实时反馈**: 及时收集和处理分析过程中的反馈

### 结果应用优化

#### 文档验证
- **团队审查**: 组织团队审查生成的文档
- **实际对比**: 与实际运行情况进行对比验证
- **用户测试**: 如有可能进行用户测试和反馈收集
- **持续更新**: 建立文档的持续更新机制

#### 知识管理
- **知识库建设**: 将分析结果整合到团队知识库
- **标准化**: 提炼标准化的分析方法和模板
- **经验分享**: 在团队中分享分析经验和教训
- **工具改进**: 基于使用反馈改进分析工具

# 命令执行限制说明

**重要提醒**: 此命令专注于从现有代码逆向推导设计文档，不涉及新的设计创意或代码实现。如需要以下服务，请使用对应的专业命令：

- **游戏设计**: 使用 `godot-game-design` 命令进行创意游戏设计
- **代码实现**: 使用 `godot-gen-code` 命令进行新功能开发
- **架构设计**: 使用 `godot-architect` 命令进行系统架构设计
- **文档生成**: 使用 `godot-gen-doc` 命令生成标准技术文档
- **问题调试**: 使用 `godot-debug` 命令解决技术问题