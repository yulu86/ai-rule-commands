---
name: smart-commit
description: 智能分析项目代码变更，自动生成符合规范的commit消息。该命令专注于Git提交、变更记录和版本管理，通过深度分析代码变更内容、影响范围和修改意图，生成专业、规范、信息丰富的Git commit消息，支持多种提交规范和自定义格式。
argument-hint: [commit类型或自定义描述]
---

# 命令参数说明

- **commit类型或自定义描述** (必需): 指定commit的类型或提供自定义描述，可以是：

  **预定义类型**:
  - **feat**: 新功能 (feature)
  - **fix**: 修复bug (bug fix)
  - **docs**: 文档变更 (documentation)
  - **style**: 代码格式化，不影响代码逻辑 (formatting, missing semi colons, etc; no code change)
  - **refactor**: 代码重构，既不是新增功能也不是修复bug (refactor)
  - **perf**: 性能优化 (performance improvements)
  - **test**: 增加测试或修改测试 (tests)
  - **chore**: 构建过程或辅助工具的变动 (maintain)
  - **ci**: 持续集成相关配置 (CI configuration files and scripts)
  - **build**: 构建系统或外部依赖变动 (build system or external dependencies)
  - **revert**: 回滚之前的提交 (revert previous commit)

  **自定义描述**:
  - **具体描述**: 如 "修复玩家卡顿问题"、"添加存档系统UI"等
  - **功能说明**: 如 "实现新的敌人AI行为"、"优化关卡加载速度"等
  - **技术描述**: 如 "重构配置管理模块"、"升级Godot引擎版本"等

# 执行步骤

## 第一阶段：变更信息收集
### 工具使用：Bash + filesystem + sequential-thinking

1. **Git状态分析** (使用 Bash 工具)
   - 执行 `git status` 分析工作区状态
   - 识别已修改、新增、删除的文件
   - 分析暂存区和未暂存的变更
   - 检查分支状态和合并情况

2. **变更内容解析** (使用 filesystem 工具)
   - 读取并分析具体的代码变更内容
   - 识别核心功能修改和配置更新
   - 分析文件变更的影响范围和依赖关系
   - 收集变更相关的测试和文档更新

3. **变更意图分析** (使用 sequential-thinking 工具)
   - 分析代码变更的深层目的和动机
   - 识别变更类型和重要程度
   - 评估变更对项目整体的影响
   - 推断最佳的消息类型和描述方式

## 第二阶段：智能消息生成
### 工具使用：sequential-thinking + memory

1. **变更分类确定** (使用 sequential-thinking 工具)
   - 根据变更内容确定主要的commit类型
   - 分析是否涉及多个类型的变更
   - 评估变更的影响范围和重要性
   - 确定是否需要多个独立的commit

2. **消息模板匹配** (使用 memory 工具)
   - 查询项目的commit消息规范和模板
   - 匹配相似的变更模式和消息格式
   - 应用项目特定的命名约定和规范
   - 考虑团队的习惯和最佳实践

3. **智能内容生成** (使用 sequential-thinking 工具)
   - 生成简洁明确的消息标题
   - 添加必要的详细说明和背景信息
   - 包含相关的技术细节和影响说明
   - 确保消息的可读性和信息完整性

## 第三阶段：质量验证与优化
### 工具使用：sequential-thinking + memory

1. **规范符合性检查** (使用 sequential-thinking 工具)
   - 验证消息格式符合Git commit规范
   - 检查消息长度和结构合理性
   - 确保使用正确的类型和格式约定
   - 验证特殊字符和编码的正确性

2. **内容质量评估** (使用 memory 工具)
   - 评估消息的清晰度和可理解性
   - 检查信息的完整性和准确性
   - 验证技术描述的正确性和专业性
   - 确保对未来维护和回滚的友好性

3. **最佳实践应用** (使用 memory 工具)
   - 应用优秀commit消息的最佳实践
   - 确保消息有助于代码历史追踪
   - 优化消息的搜索性和过滤性
   - 考虑自动化工具的解析需求

## 第四阶段：输出格式化与建议
### 工具使用：Bash + sequential-thinking

1. **格式化输出** (使用 sequential-thinking 工具)
   - 按照约定的格式输出commit消息
   - 提供多种格式选项（传统格式、Conventional Commits等）
   - 包含必要的元数据和标签信息
   - 确保输出的可读性和机器友好性

2. **提交建议生成** (使用 sequential-thinking 工具)
   - 提供commit的最佳实践建议
   - 建议是否需要拆分为多个commit
   - 推荐相关的测试和验证步骤
   - 提供后续可能的改进建议

3. **执行指导** (使用 Bash 工具)
   - 生成可直接使用的Git命令
   - 提供不同场景下的执行选项
   - 包含安全检查和备份建议
   - 指导完整的提交流程

# Agent 与 MCP 工具指定

## 主要执行 Agent

### software-developer (主导 Agent)
- **使用阶段**: 全流程主导
- **核心职责**: 代码变更分析、commit消息生成、质量验证
- **专业能力**: 软件开发实践、Git工作流、代码分析、文档编写
- **主要工具**:
  - `Bash`: Git命令执行、状态检查、文件分析
  - `filesystem`: 代码文件读取、变更内容解析
  - `sequential-thinking`: 变更意图分析、消息质量评估、最佳实践应用

### senior-code-reviewer (质量保证 Agent)
- **使用阶段**: 第二阶段和第三阶段
- **核心职责**: commit消息质量审查、规范符合性检查
- **专业能力**: 代码审查、质量标准、最佳实践验证
- **主要工具**:
  - `sequential-thinking`: 深度质量分析、规范符合性评估
  - `memory`: 查询commit消息标准和最佳实践

### general-purpose (支持 Agent)
- **使用阶段**: 第四阶段输出格式化
- **核心职责**: 格式化输出、执行指导、建议生成
- **专业能力**: 输出格式化、用户指导、最佳实践整理
- **主要工具**:
  - `sequential-thinking`: 输出格式优化、建议内容生成
  - `Bash`: 命令生成和执行指导

## MCP 工具使用策略

### 1. Bash 工具
- **使用时机**: 第一阶段状态分析、第四阶段执行指导
- **具体用途**:
  - `git status`: 分析工作区和暂存区状态
  - `git diff`: 查看具体的代码变更内容
  - `git log`: 查看历史commit格式和规范
  - `git branch`: 检查当前分支和合并状态
- **操作策略**: 安全执行Git命令，避免意外的状态变更

### 2. filesystem 工具
- **使用时机**: 第一阶段变更内容解析
- **具体用途**:
  - `read_multiple_files`: 读取多个变更文件的内容
  - `search_files`: 查找特定类型的变更文件
  - `list_directory`: 分析文件结构和变更模式
  - `directory_tree`: 理解项目的整体组织结构
- **操作策略**: 重点分析核心文件和重要变更

### 3. sequential-thinking 工具
- **使用时机**: 全程的深度分析和决策过程
- **具体用途**:
  - 分析代码变更的深层意图和影响
  - 设计合适的commit消息结构和内容
  - 评估消息质量和规范符合性
  - 生成最佳实践建议和改进方案
- **思考深度**: 根据变更复杂度调整分析深度和广度

### 4. memory 工具
- **使用时机**: 第二阶段模板匹配、第三阶段质量评估
- **具体用途**:
  - 存储和查询项目的commit消息规范
  - 匹配相似的变更模式和消息格式
  - 查询commit消息的最佳实践和标准
  - 记录特定项目的约定和习惯
- **记忆策略**: 为每个项目建立独立的commit规范知识库

# 交付件说明

## 主要交付物清单

### 1. 智能生成Commit消息 (Generated Commit Message)
**实时输出**: 直接在对话中提供格式化的commit消息

**包含内容**:
- 符合规范的commit消息标题
- 详细的变更说明和背景信息
- 相关的技术细节和影响说明
- 符合项目约定的格式和结构

**输出格式**:
```git
<type>(<scope>): <subject>

<body>

<footer>
```

**示例输出**:
```git
feat(player): 添加新的移动和跳跃机制

实现了基于物理的玩家移动系统，包括：
- 添加了新的PlayerController脚本
- 支持八方向移动和双跳跃
- 集成了动画状态机
- 添加了移动粒子效果

Closes #123
```

### 2. 变更分析报告 (Change Analysis Report)
**文件名格式**: `commit_analysis_[分支名]_[日期].md`

**包含内容**:
- 详细的变更分析和影响评估
- 变更类型和重要程度分类
- 建议的commit策略和分割方案
- 相关的风险评估和建议

**文档结构**:
```markdown
# Commit变更分析报告

## 1. 变更概览
### 1.1 变更统计
- **修改文件**: [文件数量]个
- **新增行数**: [具体数字]行
- **删除行数**: [具体数字]行
- **影响模块**: [受影响的模块列表]

### 1.2 变更类型分析
- **功能变更**: [描述功能相关的变更]
- **修复变更**: [描述bug修复相关的变更]
- **重构变更**: [描述代码重构相关的变更]
- **配置变更**: [描述配置相关的变更]

## 2. 深度分析
### 2.1 核心变更识别
### 2.2 影响范围评估
### 2.3 依赖关系分析
### 2.4 风险评估

## 3. 提交建议
### 3.1 推荐的commit策略
### 3.2 变更分割建议
### 3.3 消息格式建议
### 3.4 后续行动计划
```

### 3. Git执行命令 (Git Execution Commands)
**实时输出**: 提供可直接执行的Git命令集合

**包含内容**:
- 完整的git add命令序列
- 格式化的git commit命令
- 可选的git push命令
- 相关的安全检查和验证命令

**输出格式**:
```bash
# 安全检查 - 查看当前状态
git status

# 查看变更详情
git diff --staged
git diff

# 添加文件到暂存区
git add [文件路径1]
git add [文件路径2]
# 或添加所有变更
git add .

# 执行commit
git commit -m "生成的commit消息"

# 推送到远程仓库（可选）
git push origin [分支名]

# 验证提交结果
git log --oneline -5
```

### 4. Commit最佳实践指南 (Commit Best Practices Guide)
**文件名格式**: `commit_best_practices_[项目名]_[日期].md`

**包含内容**:
- 项目的commit消息规范和约定
- 优秀的commit消息示例和模板
- 常见的错误和避免方法
- 团队协作的最佳实践建议

**文档结构**:
```markdown
# Commit最佳实践指南

## 1. 消息格式规范
### 1.1 标准格式
### 1.2 类型约定
### 1.3 长度限制
### 1.4 语言要求

## 2. 内容质量标准
### 2.1 清晰性要求
### 2.2 完整性标准
### 2.3 一致性原则
### 2.4 可搜索性考虑

## 3. 优秀示例
### 3.1 功能开发示例
### 3.2 Bug修复示例
### 3.3 重构示例
### 3.4 文档更新示例

## 4. 常见错误
### 4.1 格式错误
### 4.2 内容问题
### 4.3 技术错误
### 4.4 团队协作问题
```

## 实时commit支持

### Commit生成状态跟踪
**实时输出**: 在对话中提供实时的commit生成进度和建议

**包含内容**:
- 当前分析阶段和发现的重要变更
- commit消息的生成状态和质量评估
- 遇到的问题和解决方案
- 下一步操作建议和注意事项

**输出格式**:
```markdown
## 📊 Commit分析进度
**当前阶段**: [具体分析阶段]
**发现变更**: [变更文件数量]个文件
**分析进度**: [百分比]%

## 🔍 重要变更发现
- **核心功能**: [发现的重要功能变更]
- **关键修复**: [识别的关键bug修复]
- **影响范围**: [变更影响的核心模块]
- **风险评估**: [潜在的变更风险]

## 📝 消息生成状态
- **类型确定**: [选择的commit类型]
- **标题生成**: [消息标题的生成状态]
- **内容完善**: [详细内容的编写状态]
- **格式验证**: [格式规范验证结果]

## ⚠️ 注意事项
- **建议拆分**: [建议拆分为多个commit的变更]
- **待确认**: [需要用户确认的变更内容]
- **风险提示**: [潜在的风险和注意事项]
- **后续行动**: [推荐的后级行动步骤]
```

# 约束与限制条件

## 变更分析约束

### 代码访问约束
- **权限限制**: 只能分析有读取权限的文件变更
- **文件大小**: 大文件的完整分析可能受到性能限制
- **二进制文件**: 无法直接分析二进制文件的内容变更
- **编码格式**: 非标准编码的文件可能存在解析问题

### 分析精度约束
- **静态分析**: 基于静态代码分析，无法理解运行时行为
- **意图理解**: 对代码变更的深层意图理解存在局限性
- **影响评估**: 变更影响范围的评估可能不够全面
- **复杂逻辑**: 复杂业务逻辑的准确理解存在挑战

### 消息质量约束
- **信息缺失**: 代码变更的上下文信息可能不完整
- **业务理解**: 对业务需求的理解可能存在偏差
- **技术细节**: 某些技术细节的准确描述可能不够精确
- **个性化需求**: 无法完全满足个性化的消息风格需求

## 技术约束条件

### Git工具约束
- **版本兼容**: 不同Git版本的命令和行为可能存在差异
- **配置差异**: 不同Git配置可能影响分析结果
- **分支复杂性**: 复杂的分支和合并历史增加分析难度
- **远程状态**: 远程仓库的状态可能无法完全获取

### 文件系统约束
- **文件数量**: 大量文件的批量分析可能影响性能
- **文件路径**: 特殊字符路径的处理可能存在限制
- **权限问题**: 文件权限问题可能影响内容读取
- **并发修改**: 分析过程中的文件变更可能导致不一致

### 算法能力约束
- **语义理解**: 对代码语义的理解能力存在局限
- **上下文关联**: 跨文件和模块的关联分析可能不够深入
- **模式识别**: 复杂变更模式的识别准确率有限
- **预测能力**: 对变更未来影响的预测能力有限

## 使用约束条件

### 执行环境约束
- **Git仓库**: 必须在有效的Git仓库中执行
- **工作目录**: 需要在Git工作目录中运行
- **网络连接**: 某些功能可能需要网络连接支持
- **系统权限**: 需要足够的文件系统访问权限

### 责任分担约束
- **最终审核**: 用户需要对生成的commit消息进行最终审核
- **执行责任**: commit执行的责任和后果由用户承担
- **备份责任**: 重要变更的备份和恢复由用户负责
- **团队协调**: 与团队规范和流程的协调由用户负责

### 质量保证约束
- **人工验证**: 建议人工验证重要变更的分析结果
- **测试确认**: 建议在测试环境中验证变更的影响
- **团队确认**: 重要commit建议与团队成员进行确认
- **持续改进**: 基于使用反馈持续改进分析质量

## 伦理约束条件

### 数据安全约束
- **隐私保护**: 保护代码中的敏感信息和隐私数据
- **机密信息**: 避免在commit消息中泄露商业机密
- **访问控制**: 遵守项目的访问控制和安全策略
- **数据完整性**: 确保分析过程中数据的完整性和安全

### 专业责任约束
- **准确性**: 对分析结果的准确性承担专业责任
- **透明度**: 透明地说明分析方法的能力和限制
- **持续学习**: 持续学习改进commit消息生成技术
- **最佳实践**: 遵循软件开发和版本管理的最佳实践

# 使用场景与最佳实践

## 适用场景

### 日常开发工作流
- **功能开发**: 新功能开发后的代码提交
- **Bug修复**: 问题修复和调试后的变更提交
- **代码重构**: 代码结构优化和重构后的提交
- **配置更新**: 项目配置和依赖更新的提交

### 团队协作场景
- **代码审查**: 代码审查通过后的正式提交
- **分支合并**: 功能分支合并到主分支
- **版本发布**: 版本发布前的最终commit
- **紧急修复**: 生产环境紧急问题的修复提交

### 项目管理场景
- **里程碑提交**: 重要的开发里程碑节点
- **实验性提交**: 实验性功能和研究性代码
- **文档更新**: 项目文档和说明文件的更新
- **工具更新**: 开发工具和构建系统的更新

### 质量保证场景
- **测试提交**: 测试用例和测试代码的提交
- **性能优化**: 性能改进和优化相关的提交
- **安全修复**: 安全漏洞修复和加固的提交
- **规范化**: 代码规范化和格式化的提交

## 不适用场景

### 非代码变更
- **纯文档提交**: 纯文档内容的专业编辑
- **翻译工作**: 多语言翻译和本地化工作
- **美术资源**: 图像、音频、视频等媒体资源变更
- **外部工具**: 外部工具和服务的配置变更

### 复杂合并场景
- **冲突解决**: 复杂的合并冲突解决
- **历史重写**: Git历史的重写和整理
- **分支重构**: 大规模的分支结构调整
- **多仓库操作**: 跨多个仓库的复杂操作

### 自动化集成场景
- **CI/CD流水线**: 自动化构建和部署流水线
- **机器人提交**: 自动化机器人的提交操作
- **批量操作**: 大规模批量文件操作
- **同步操作**: 实时同步和镜像操作

## 最佳实践指南

### 变更准备优化

#### 代码组织
- **逻辑分组**: 将相关的变更组织在一起
- **原子性**: 确保每个commit的变更逻辑是原子的
- **独立性**: 避免将不相关的变更混合在一起
- **完整性**: 确保每个commit的变更是完整和可测试的

#### 状态清理
- **临时文件**: 清理临时文件和调试代码
- **注释清理**: 移除或完善调试注释
- **格式统一**: 确保代码格式的一致性
- **测试通过**: 确保所有相关测试通过

### 消息质量优化

#### 内容组织
- **标题简洁**: 使用简洁明确的标题描述主要变更
- **详细说明**: 在body中提供必要的详细说明和背景
- **影响范围**: 明确说明变更的影响范围和后果
- **相关引用**: 引用相关的issue、PR或讨论

#### 格式规范
- **类型选择**: 选择最合适的commit类型
- **范围限定**: 使用scope限定变更的影响范围
- **语言一致**: 使用一致的语言和术语
- **长度控制**: 控制标题和正文的合理长度

### 团队协作优化

#### 沟通协调
- **提前沟通**: 重要变更提前与团队沟通
- **标准统一**: 遵循团队的commit消息标准
- **及时反馈**: 及时提供和接受反馈意见
- **知识共享**: 分享有价值的变更经验和教训

#### 流程规范
- **分支策略**: 遵循项目的分支管理策略
- **审查流程**: 遵循代码审查和合并流程
- **测试要求**: 满足项目的测试覆盖率要求
- **文档同步**: 保持相关文档的同步更新

# 命令执行限制说明

**重要提醒**: 此命令专注于智能生成commit消息和版本管理支持，不涉及代码开发、测试执行或部署操作。如需要以下服务，请使用对应的专业工具：

- **代码开发**: 使用 `godot-gen-code` 命令进行功能开发
- **代码审查**: 使用 `godot-code-reviewer` 命令进行代码质量审查
- **问题调试**: 使用 `godot-debug` 命令解决技术问题
- **文档生成**: 使用 `godot-gen-doc` 命令生成技术文档
- **Git高级操作**: 对于复杂的Git操作，建议使用专业的Git工具或咨询Git专家