---
name: software-developer-guide
description: 专业软件开发实现指导工具，支持代码实现、性能优化和最佳实践应用。该命令专注于高质量代码编写、设计模式应用、性能优化和代码重构，能够生成专业的实现方案、代码示例和开发指导，为软件开发者提供完整的实现支持。
argument-hint: [功能/模块] [编程语言] [实现深度]
---

# 命令参数说明

- **功能/模块** (必需): 指定代码实现的目标，可以是：
  - **核心功能**: 如 "用户认证系统"、"支付处理"、"文件上传下载"等
  - **业务模块**: 如 "订单管理"、"库存控制"、"客户关系管理"等
  - **技术组件**: 如 "缓存服务"、"消息队列"、"搜索引擎"等
  - **算法实现**: 如 "推荐算法"、"数据挖掘"、"图像处理"等
  - **集成功能**: 如 "第三方登录"、"支付集成"、"邮件发送"等

- **编程语言** (可选): 指定实现使用的编程语言
  - **Python**: Python语言实现，适用于数据处理、机器学习、Web开发
  - **Java**: Java语言实现，适用于企业级应用、安卓开发、大数据
  - **JavaScript/TypeScript**: JS/TS实现，适用于前端开发、Node.js后端
  - **Go**: Go语言实现，适用于微服务、云原生、并发编程
  - **C#**: C#实现，适用于.NET平台、游戏开发、企业应用
  - **Rust**: Rust语言实现，适用于系统编程、安全关键应用
  - **默认值**: 如未指定，基于功能特点推荐最适合的编程语言

- **实现深度** (可选): 指定代码实现的详细程度
  - **核心实现**: 生成核心功能和关键代码
  - **完整实现**: 生成完整的功能模块和代码
  - **详细实现**: 生成包含错误处理、测试、文档的完整代码
  - **生产级实现**: 生成生产就绪的代码，包含监控、日志、优化
  - **默认值**: 如未指定，默认为完整实现

# 执行步骤

**当前开发指导目标**: $ARGUMENTS

## 第一阶段：需求分析与技术选型
### 工具使用：sequential-thinking + memory + context7

1. **功能需求分析** (使用 sequential-thinking 工具)
   - 深度分析功能需求和业务逻辑
   - 确定核心算法和数据结构需求
   - 分析性能和并发要求
   - 制定代码实现的验收标准

2. **技术方案设计** (使用 memory + context7 工具)
   - 查询最新的编程语言特性和最佳实践
   - 研究相关的开源库和框架
   - 分析不同的实现方案和优缺点
   - 选择最适合的技术栈和工具

3. **架构设计规划** (使用 sequential-thinking 工具)
   - 设计代码的整体架构和模块结构
   - 确定设计模式和编程范式
   - 规划接口设计和数据流
   - 制定代码组织和命名规范

## 第二阶段：代码设计与实现
### 工具使用：software-developer + sequential-thinking

1. **核心代码实现** (使用 software-developer Agent)
   - 编写核心功能代码和算法实现
   - 实现数据结构和业务逻辑
   - 设计接口和API端点
   - 处理异常情况和边界条件

2. **性能优化设计** (使用 sequential-thinking 工具)
   - 优化算法复杂度和数据结构选择
   - 设计缓存策略和性能优化
   - 考虑并发和线程安全问题
   - 制定内存管理和资源优化策略

3. **安全性和健壮性** (使用 sequential-thinking 工具)
   - 实现输入验证和数据校验
   - 设计错误处理和日志记录
   - 考虑安全漏洞和防护措施
   - 制定单元测试和集成测试策略

## 第三阶段：测试与质量保证
### 工具使用：code-reviewer + memory + sequential-thinking

1. **代码质量审查** (使用 code-reviewer Agent)
   - 检查代码质量和编码规范
   - 验证功能实现的正确性
   - 优化代码结构和可读性
   - 确保符合最佳实践和设计模式

2. **测试用例设计** (使用 memory 工具)
   - 设计全面的单元测试用例
   - 创建集成测试和端到端测试
   - 实现性能测试和压力测试
   - 制定测试数据和Mock策略

3. **文档和注释** (使用 sequential-thinking 工具)
   - 编写详细的代码注释和文档
   - 创建API文档和使用说明
   - 制作配置文件和部署说明
   - 补充故障排除和维护指南

## 第四阶段：优化与部署支持
### 工具使用：devops-engineer + software-developer

1. **部署配置优化** (使用 devops-engineer Agent)
   - 设计部署脚本和配置文件
   - 实现容器化和自动化部署
   - 配置监控和日志收集
   - 制定环境管理和版本控制

2. **性能调优完善** (使用 software-developer Agent)
   - 进行代码性能分析和优化
   - 优化数据库查询和缓存策略
   - 调整并发和资源使用
   - 实现负载均衡和扩展性设计

3. **最佳实践完善** (使用 software-developer Agent)
   - 应用最新的编程语言特性
   - 实现设计模式和架构原则
   - 优化开发体验和维护效率
   - 制定代码重构和升级策略

# Agent 与 MCP 工具指定

## 主要执行 Agent

### software-developer (主导 Agent)
- **使用阶段**: 第二阶段代码实现、第四阶段性能调优
- **核心职责**: 高质量代码编写、设计模式应用、性能优化、代码重构
- **专业能力**: 多语言编程、软件架构实现、性能优化、最佳实践实施
- **主要工具**:
  - `sequential-thinking`: 代码架构设计、算法优化、性能调优
  - `context7`: 最新语言特性查询、库文档获取、最佳实践研究
  - `memory`: 编码规范查询、设计模式库、代码模板应用

### code-reviewer (质量保证支持 Agent)
- **使用阶段**: 第三阶段代码质量审查
- **核心职责**: 代码质量检查、错误识别、最佳实践验证
- **专业能力**: 代码异味识别、性能分析、安全检查、标准化审查
- **主要工具**:
  - `sequential-thinking`: 代码质量分析、优化建议、错误诊断
  - `memory`: 质量标准查询、审查清单、最佳实践应用

### devops-engineer (部署支持支持 Agent)
- **使用阶段**: 第四阶段部署配置优化
- **触发条件**: 需要部署和运维相关支持时
- **核心职责**: 部署自动化、监控配置、运维脚本编写
- **专业能力**: CI/CD流水线、容器化部署、基础设施即代码
- **主要工具**:
  - `sequential-thinking`: 部署策略设计、运维方案优化
  - `memory`: DevOps最佳实践、部署模式查询

### senior-code-reviewer (深度质量审查 Agent)
- **使用阶段**: 第三阶段深度代码审查
- **核心职责**: 深度代码审查、架构验证、性能瓶颈分析
- **专业能力**: 代码质量保证、性能分析、安全性审查
- **主要工具**:
  - `sequential-thinking`: 深度代码分析、架构评估、性能优化建议
  - `memory`: 高级审查标准、质量指标查询

## MCP 工具使用策略

### 1. sequential-thinking 工具
- **使用时机**: 第一阶段需求分析、第二阶段代码设计、第四阶段优化
- **具体用途**:
  - 深度分析功能需求和实现方案
  - 设计合理的代码架构和数据结构
  - 分析性能瓶颈和优化策略
  - 优化代码结构和可维护性
- **思考深度**: 根据实现深度要求和功能复杂度调整分析深度

### 2. memory 工具
- **使用时机**: 第一阶段技术选型、第三阶段测试设计、全程知识支持
- **具体用途**:
  - 查询编程语言特性和最佳实践
  - 收集相关的设计模式和代码模板
  - 存储重要的代码决策和实现方案
  - 建立编程主题的知识库和案例库
- **记忆策略**: 为每个编程项目建立独立的知识图谱

### 3. context7 工具
- **使用时机**: 第一阶段技术选型、第二阶段库查询、第三阶段文档参考
- **具体用途**:
  - 查询最新的编程语言文档和特性
  - 获取相关库和框架的使用指南
  - 收集最新的开发工具和最佳实践
  - 查询API文档和代码示例
- **查询策略**: 使用编程语言+功能需求+库框架进行查询

### 4. filesystem 工具
- **使用时机**: 第二阶段代码编写、第三阶段文档生成、全程文件管理
- **具体用途**:
  - 创建和编辑代码文件和配置文件
  - 组织项目结构和文档文件
  - 管理测试用例和数据文件
  - 生成部署脚本和配置文件
- **操作策略**: 遵循代码管理规范和项目结构标准

# 交付件说明

## 主要交付物清单

### 1. 核心实现代码 (Core Implementation Code)
**文件格式**: `main_[功能名称].[语言扩展名]`, `[功能名称]_service.[语言扩展名]`

**包含内容**:
- 完整的功能实现代码
- 核心算法和业务逻辑
- 数据处理和接口实现
- 错误处理和异常管理

**代码结构**:
```python
# [编程语言示例：Python]
"""
[功能模块名称]
核心功能实现
"""

class [功能名称]Service:
    """[功能描述]"""

    def __init__(self, config):
        """初始化服务"""
        self.config = config
        self.logger = self._setup_logger()

    def [核心方法](self, [参数]):
        """
        [方法描述]

        Args:
            [参数]: [参数描述]

        Returns:
            [返回值描述]

        Raises:
            [异常描述]
        """
        # [核心实现逻辑]
        pass

    def _helper_method(self, [参数]):
        """辅助方法实现"""
        pass

    def _validate_input(self, [参数]):
        """输入验证"""
        pass
```

### 2. 数据模型代码 (Data Models)
**文件格式**: `models_[功能名称].[语言扩展名]`, `schemas_[功能名称].[语言扩展名]`

**包含内容**:
- 数据模型和类定义
- 数据验证和序列化
- 数据转换和映射
- 数据库操作方法

**代码结构**:
```python
# 数据模型示例
from dataclasses import dataclass
from typing import Optional, List
from datetime import datetime

@dataclass
class [数据模型名称]:
    """[数据模型描述]"""

    id: Optional[str] = None
    name: str
    description: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def to_dict(self) -> dict:
        """转换为字典"""
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }

    @classmethod
    def from_dict(cls, data: dict) -> '[数据模型名称]':
        """从字典创建实例"""
        return cls(**data)
```

### 3. 测试用例代码 (Test Cases)
**文件格式**: `test_[功能名称].[语言扩展名]`, `[功能名称]_test.[语言扩展名]`

**包含内容**:
- 完整的单元测试用例
- 集成测试和端到端测试
- 性能测试和压力测试
- 测试数据和Mock对象

**代码结构**:
```python
# 测试用例示例
import unittest
from unittest.mock import Mock, patch
from [模块名称] import [功能名称]Service

class Test[功能名称]Service(unittest.TestCase):
    """[功能名称]服务测试"""

    def setUp(self):
        """测试初始化"""
        self.config = {'key': 'value'}
        self.service = [功能名称]Service(self.config)

    def test_[测试场景](self):
        """测试[测试场景]"""
        # Given
        [输入数据] = [测试数据]

        # When
        result = self.service.[测试方法]([输入数据])

        # Then
        self.assertEqual(result, [期望结果])

    def test_[异常场景](self):
        """测试[异常场景]"""
        with self.assertRaises([异常类型]):
            self.service.[测试方法]([异常输入])

    @patch('[外部依赖]')
    def test_[集成测试](self, mock_dependency):
        """测试[集成场景]"""
        mock_dependency.return_value = [模拟返回值]
        result = self.service.[集成方法]()
        self.assertIsNotNone(result)

if __name__ == '__main__':
    unittest.main()
```

### 4. 配置文件 (Configuration Files)
**文件格式**: `config.yaml`, `settings.json`, `.env.example`

**包含内容**:
- 应用配置和环境变量
- 数据库连接和认证信息
- 日志配置和监控设置
- 部署和运行环境配置

**配置结构**:
```yaml
# 配置文件示例
app:
  name: "[应用名称]"
  version: "1.0.0"
  debug: false
  port: 8080

database:
  host: "${DB_HOST:localhost}"
  port: "${DB_PORT:5432}"
  name: "${DB_NAME:app_db}"
  username: "${DB_USER:app_user}"
  password: "${DB_PASSWORD:app_pass}"

logging:
  level: "INFO"
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  file: "logs/app.log"

cache:
  type: "redis"
  host: "${CACHE_HOST:localhost}"
  port: "${CACHE_PORT:6379}"
  ttl: 3600

security:
  jwt_secret: "${JWT_SECRET}"
  jwt_expiry: 24
  encryption_key: "${ENCRYPTION_KEY}"
```

### 5. API接口代码 (API Interface)
**文件格式**: `api_[功能名称].[语言扩展名]`, `routes_[功能名称].[语言扩展名]`

**包含内容**:
- REST API接口实现
- 请求验证和响应格式化
- 错误处理和状态码管理
- API文档和版本控制

**代码结构**:
```python
# API接口示例
from flask import Flask, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from [服务模块] import [功能名称]Service

app = Flask(__name__)
service = [功能名称]Service(app.config)

@app.route('/api/[功能名称]', methods=['GET'])
@jwt_required()
def get_[功能名称]():
    """获取[功能名称]列表"""
    try:
        user_id = get_jwt_identity()
        params = request.args.to_dict()
        result = service.get_list(user_id, params)
        return jsonify({
            'success': True,
            'data': result,
            'message': '获取成功'
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e),
            'message': '获取失败'
        }), 500

@app.route('/api/[功能名称]', methods=['POST'])
@jwt_required()
def create_[功能名称]():
    """创建[功能名称]"""
    try:
        user_id = get_jwt_identity()
        data = request.get_json()
        result = service.create(user_id, data)
        return jsonify({
            'success': True,
            'data': result,
            'message': '创建成功'
        }), 201
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e),
            'message': '创建失败'
        }), 400
```

### 6. 部署脚本 (Deployment Scripts)
**文件格式**: `Dockerfile`, `docker-compose.yml`, `deploy.sh`

**包含内容**:
- Docker容器化配置
- 部署和运行脚本
- 环境变量和密钥管理
- 健康检查和监控配置

**部署配置**:
```dockerfile
# Dockerfile示例
FROM python:3.11-slim

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 设置环境变量
ENV PYTHONPATH=/app
ENV FLASK_APP=app.py

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

# 启动命令
CMD ["python", "app.py"]
```

## 实现代码支持

### 实现进度跟踪
**实时输出**: 在对话中提供实时的代码实现进度和关键决策

**包含内容**:
- 当前代码实现阶段和完成进度
- 重要功能模块的实现状态
- 遇到的技术挑战和解决方案
- 下一步实现内容和优化建议

**输出格式**:
```markdown
## 💻 代码实现进度报告
**当前阶段**: [具体实现阶段]
**完成度**: [百分比]%
**编程语言**: [选择的编程语言]

## 📊 实现发现状态
- **已完成模块**: [已实现的功能模块]
- **进行中代码**: [正在编写的代码部分]
- **待开始功能**: [待实现的功能模块]

## 🎯 关键技术决策
- **架构选择**: [选择的代码架构和理由]
- **设计模式**: [应用的设计模式和使用场景]
- **技术栈**: [使用的主要技术和库]
- **优化策略**: [采用的关键优化策略]

## 📋 下一步计划
1. [下一步要实现的功能模块]
2. [需要重点优化的性能点]
3. [需要补充的测试用例]
4. [需要完善的文档和配置]
```

# 约束与限制条件

## 实现内容约束

### 专业性约束
- **代码质量**: 确保生成代码的质量和专业性
- **标准合规**: 遵循编程语言规范和最佳实践
- **安全可靠**: 代码实现必须安全可靠，无安全漏洞
- **性能优化**: 考虑代码性能和资源使用效率

### 完整性约束
- **功能完整**: 确保实现所有必要的功能
- **错误处理**: 包含完善的错误处理和异常管理
- **输入验证**: 实现全面的输入验证和数据校验
- **文档完整**: 提供完整的代码注释和使用文档

### 可维护性约束
- **代码清晰**: 代码结构清晰，易于理解和维护
- **模块化**: 采用模块化设计，便于扩展和重用
- **标准化**: 遵循编码规范和命名约定
- **可测试**: 代码具有良好的可测试性

## 技术约束条件

### 编程语言约束
- **语言特性**: 充分利用编程语言的特性和优势
- **版本兼容**: 考虑编程语言版本兼容性
- **生态支持**: 考虑语言生态和社区支持
- **学习成本**: 评估团队的学习成本和技术接受度

### 框架和库约束
- **版本稳定**: 选择稳定可靠的框架和库版本
- **许可证合规**: 确保使用的库许可证合规
- **安全审计**: 使用经过安全审计的第三方库
- **维护活跃**: 选择维护活跃的社区项目

### 性能约束
- **资源使用**: 控制内存和CPU资源使用
- **响应时间**: 满足性能响应时间要求
- **并发处理**: 考虑并发访问和线程安全
- **扩展性**: 设计具有良好扩展性的代码

## 使用约束条件

### 需求明确性约束
- **功能清晰**: 功能需求必须清晰明确
- **性能要求**: 性能要求和约束需要明确
- **环境要求**: 运行环境和技术约束需要明确
- **标准要求**: 编码标准和质量要求必须明确

### 应用范围约束
- **业务适配**: 实现代码需要适配具体业务场景
- **技术适配**: 考虑现有技术栈和架构约束
- **团队适配**: 适配开发团队的技能水平和工作方式
- **运维适配**: 考虑运维部署和监控需求

### 验证责任约束
- **代码测试**: 生成的代码需要经过充分测试
- **性能验证**: 建议进行性能测试和压力测试
- **安全审查**: 需要进行安全代码审查
- **集成测试**: 在实际环境中进行集成测试

## 伦理约束条件

### 知识产权约束
- **开源合规**: 遵循开源软件许可证要求
- **代码引用**: 尊重他人的代码成果和知识产权
- **合规使用**: 确保第三方库的合规使用
- **透明度**: 对使用的第三方组件保持透明

### 专业责任约束
- **代码质量**: 对生成代码的质量承担专业责任
- **安全保障**: 确保代码的安全性和可靠性
- **持续学习**: 持续学习新的编程技术和最佳实践
- **知识分享**: 促进编程知识的分享和传承

# 使用场景与最佳实践

## 适用场景

### 新功能开发
- **业务功能**: 实现具体的业务功能模块
- **技术组件**: 开发可重用的技术组件
- **API接口**: 实现REST API和微服务接口
- **数据处理**: 开发数据处理和分析功能

### 系统重构
- **代码优化**: 优化现有代码的性能和结构
- **技术升级**: 升级到新的技术栈和框架
- **架构重构**: 重构代码架构和设计模式
- **代码清理**: 清理技术债务和改进代码质量

### 工具开发
- **开发工具**: 开发提高开发效率的工具
- **自动化脚本**: 编写自动化部署和运维脚本
- **测试工具**: 开发测试和质量保证工具
- **监控工具**: 实现系统监控和分析工具

### 原型开发
- **技术验证**: 快速实现技术验证原型
- **概念验证**: 开发业务概念验证原型
- **演示系统**: 构建产品演示和展示系统
- **MVP开发**: 实现最小可行产品

## 不适用场景

### 系统设计
- **架构设计**: 不替代系统架构设计工具
- **数据库设计**: 不进行数据库schema设计
- **网络架构**: 不设计复杂的网络和基础设施架构
- **安全架构**: 不替代专业的安全架构设计

### 项目管理
- **项目管理**: 不进行项目管理和进度控制
- **需求管理**: 不替代需求管理和变更控制
- **团队管理**: 不涉及团队组织和人员管理
- **质量保证**: 不替代完整的质量管理体系

### 运维部署
- **基础设施**: 不进行基础设施的设计和管理
- **网络配置**: 不涉及网络设备的配置管理
- **安全运维**: 不替代专业的安全运维管理
- **监控配置**: 不进行详细的监控配置和告警设置

## 最佳实践指南

### 代码编写优化

#### 代码质量保证
- **编码规范**: 严格遵循编程语言的编码规范
- **命名约定**: 使用清晰、一致的命名约定
- **注释文档**: 编写清晰的代码注释和文档
- **版本控制**: 使用版本控制系统管理代码变更

#### 性能优化
- **算法优化**: 选择高效的算法和数据结构
- **内存管理**: 合理管理内存使用和垃圾回收
- **并发处理**: 正确处理并发访问和线程安全
- **缓存策略**: 实现适当的缓存和优化策略

### 测试和质量保证

#### 测试策略
- **测试驱动**: 采用测试驱动开发(TDD)方法
- **单元测试**: 编写全面的单元测试用例
- **集成测试**: 实现集成测试和端到端测试
- **性能测试**: 进行性能测试和压力测试

#### 代码审查
- **同行审查**: 实施代码同行审查流程
- **静态分析**: 使用静态代码分析工具
- **安全扫描**: 进行代码安全漏洞扫描
- **质量度量**: 建立代码质量度量体系

### 团队协作优化

#### 知识管理
- **代码分享**: 建立代码分享和评审机制
- **技术培训**: 提供编程技术培训和指导
- **文档维护**: 维护项目文档和知识库
- **最佳实践**: 沉淀和分享编程最佳实践

#### 工具支持
- **IDE配置**: 优化开发环境配置和工具链
- **自动化工具**: 使用自动化工具提高开发效率
- **持续集成**: 建立持续集成和部署流程
- **代码模板**: 创建可重用的代码模板和库

# 命令执行限制说明

**重要提醒**: 此命令专注于专业的代码实现和技术开发指导，不涉及系统架构设计、项目管理或运维部署。如需要以下服务，请使用对应的专业命令：

- **需求分析**: 使用 `software-requirements-analysis` 命令进行需求分析
- **架构设计**: 使用 `software-architect-design` 命令进行架构设计
- **代码审查**: 使用 `code-reviewer` 命令进行代码质量审查
- **技术选型**: 使用 `tech-selection-analysis` 命令进行技术选型分析
- **DevOps支持**: 使用 `devops-engineer` 命令进行部署和运维
- **系统设计**: 使用 `system-designer` 命令进行创意系统设计