---
name: software-low-level-design
description: 专业软件详细设计文档生成工具，根据架构设计和用户故事生成详细的设计文档，指导开发人员完成用户故事开发。该命令专注于将高阶架构设计转化为具体的实施细节，包括组件设计、接口定义、数据结构、算法设计和实现策略，为开发团队提供完整的技术实现指导。
argument-hint: [用户故事/功能模块] [设计详细程度] [技术栈/架构类型]
---

# 命令参数说明

- **用户故事/功能模块** (必需): 指定详细设计的目标，可以是：
  - **用户故事**: 如 "用户注册登录功能"、"商品搜索与筛选"、"订单处理流程"等
  - **功能模块**: 如 "支付网关模块"、"消息通知服务"、"数据分析仪表板"等
  - **系统组件**: 如 "用户认证组件"、"缓存管理系统"、"API路由处理"等
  - **业务流程**: 如 "购物车结算流程"、"用户权限验证流程"、"数据同步机制"等

- **设计详细程度** (可选): 指定详细设计的深度和粒度
  - **概要设计**: 生成主要组件和接口的概要设计
  - **详细设计**: 生成完整的技术实现细节和代码结构
  - **接口设计**: 专注于API接口和数据结构设计
  - **算法设计**: 专注于核心算法和业务逻辑设计
  - **数据库设计**: 专注于数据模型和数据库结构设计
  - **默认值**: 如未指定，默认为详细设计

- **技术栈/架构类型** (可选): 指定技术栈约束和架构模式
  - **后端技术**: Spring Boot, Node.js, Django, Flask等
  - **前端技术**: React, Vue, Angular, Next.js等
  - **数据库**: MySQL, PostgreSQL, MongoDB, Redis等
  - **架构模式**: MVC, MVVM, 微服务, Serverless等
  - **云原生**: Kubernetes, Docker, Lambda, Cloud Functions等
  - **默认值**: 如未指定，基于功能特点推荐合适的技术栈

# 执行步骤

**当前详细设计目标**: $ARGUMENTS

## 第一阶段：需求分析与架构理解
### 工具使用：sequential-thinking + memory

1. **用户故事解析** (使用 sequential-thinking 工具)
   - 深度解析用户故事的验收条件和业务规则
   - 识别功能需求和非功能性要求
   - 分析业务流程和数据流转
   - 确定设计的边界和约束条件

2. **架构设计分析** (使用 memory + sequential-thinking 工具)
   - 理解现有的架构设计和技术约束
   - 分析相关组件的接口和依赖关系
   - 识别设计模式和技术标准的适用性
   - 确认技术栈和开发框架的约束

3. **技术约束评估** (使用 sequential-thinking 工具)
   - 评估现有技术栈的能力和限制
   - 分析性能、安全、可扩展性要求
   - 识别技术风险和实施难点
   - 制定技术选型和实现策略

## 第二阶段：详细技术设计
### 工具使用：software-developer + sequential-thinking + memory

1. **组件结构设计** (使用 software-developer Agent)
   - 设计具体的类结构和模块组织
   - 定义组件间的接口和通信协议
   - 设计数据流和控制流的实现
   - 制定组件的生命周期管理策略

2. **接口规范设计** (使用 sequential-thinking 工具)
   - 设计详细的API接口规范和数据格式
   - 定义输入输出参数和验证规则
   - 设计错误处理和异常管理机制
   - 制定接口版本管理和兼容策略

3. **数据结构设计** (使用 sequential-thinking 工具)
   - 设计具体的数据模型和实体关系
   - 定义数据验证规则和业务约束
   - 设计数据访问层和存储策略
   - 制定数据缓存和同步机制

## 第三阶段：实现策略设计
### 工具使用：software-developer + senior-code-reviewer + memory

1. **核心算法设计** (使用 software-developer Agent)
   - 设计核心业务逻辑的算法实现
   - 定义算法的复杂度和性能要求
   - 设计边界条件和异常处理
   - 制定算法的测试和验证策略

2. **设计模式应用** (使用 sequential-thinking 工具)
   - 选择适合的设计模式和架构模式
   - 设计模式的实现策略和代码结构
   - 分析模式的优缺点和适用场景
   - 制定模式使用的最佳实践

3. **错误处理设计** (使用 sequential-thinking 工具)
   - 设计完整的错误处理和恢复机制
   - 定义异常类型和处理策略
   - 设计日志记录和监控机制
   - 制定故障诊断和问题排查流程

## 第四阶段：测试与质量保证
### 工具使用：senior-code-reviewer + sequential-thinking + memory

1. **测试策略设计** (使用 senior-code-reviewer Agent)
   - 设计单元测试和集成测试策略
   - 定义测试用例和验收标准
   - 设计性能测试和压力测试
   - 制定自动化测试和持续集成策略

2. **代码质量标准** (使用 sequential-thinking 工具)
   - 定义编码规范和代码质量标准
   - 设计代码审查和检查清单
   - 制定重构和优化策略
   - 建立代码质量度量和监控

3. **部署和运维设计** (使用 sequential-thinking 工具)
   - 设计部署策略和环境配置
   - 制定监控和告警机制
   - 设计备份和恢复策略
   - 制定运维文档和操作手册

## 第五阶段：文档生成与验证
### 工具使用：design-doc-writer + senior-code-reviewer + memory

1. **详细设计文档生成** (使用 design-doc-writer Agent)
   - 生成完整的详细设计文档
   - 创建技术实现指导和代码示例
   - 制作接口文档和数据字典
   - 编写开发指南和最佳实践

2. **设计验证和评审** (使用 senior-code-reviewer Agent)
   - 验证技术方案的可行性和完整性
   - 评估设计的性能和安全特性
   - 检查设计的一致性和可维护性
   - 制定设计改进和优化建议

3. **开发指导完善** (使用 memory 工具)
   - 补充技术参考和学习资源
   - 提供相关的工具和框架指导
   - 建立知识库和经验分享
   - 制定持续改进和优化机制

# Agent 与 MCP 工具指定

## 主要执行 Agent

### software-developer (主导 Agent)
- **使用阶段**: 第二阶段详细技术设计、第三阶段实现策略设计
- **核心职责**: 技术实现设计、组件结构设计、接口规范制定
- **专业能力**: 软件开发实现、设计模式应用、性能优化、代码质量保证
- **主要工具**:
  - `sequential-thinking`: 技术方案设计、实现策略分析、性能优化
  - `memory`: 设计模式库、最佳实践、技术标准查询
  - `tavily-mcp`: 技术趋势研究、实现方案调研

### senior-code-reviewer (质量保证支持 Agent)
- **使用阶段**: 第四阶段测试与质量保证、第五阶段设计验证
- **核心职责**: 代码质量审查、测试策略设计、设计验证评估
- **专业能力**: 专业代码审查、错误调试分析、质量保证标准
- **主要工具**:
  - `sequential-thinking`: 质量标准分析、测试策略设计、风险评估
  - `memory`: 代码质量标准、审查清单、最佳实践查询

### design-doc-writer (文档生成支持 Agent)
- **使用阶段**: 第五阶段文档生成与验证
- **核心职责**: 详细设计文档撰写、技术文档标准化、开发指导编写
- **专业能力**: 技术文档写作、设计文档标准化、开发指南制作
- **主要工具**:
  - `filesystem`: 文档创建、编辑、格式处理
  - `sequential-thinking`: 文档结构设计、内容组织
  - `memory`: 文档模板查询、标准格式应用

### system-designer (概念验证支持 Agent)
- **使用阶段**: 第一阶段需求分析、概念设计验证
- **触发条件**: 需要进行业务流程分析和系统概念验证时
- **核心职责**: 业务流程分析、系统概念设计、用户体验设计
- **专业能力**: 系统设计理论、业务流程建模、用户体验架构
- **主要工具**:
  - `sequential-thinking`: 业务需求分析、系统概念验证
  - `tavily-mcp`: 行业最佳实践、设计趋势研究

## MCP 工具使用策略

### 1. sequential-thinking 工具
- **使用时机**: 第一阶段需求分析、第二阶段技术设计、第三阶段实现策略、第四阶段质量保证
- **具体用途**:
  - 深度解析用户故事和业务需求
  - 设计具体的组件结构和接口规范
  - 分析技术方案的可行性和优缺点
  - 制定测试策略和质量保证措施
- **思考深度**: 根据设计详细程度要求调整技术分析的深度

### 2. memory 工具
- **使用时机**: 第一阶段架构理解、第二阶段技术设计、第五阶段文档完善
- **具体用途**:
  - 查询设计模式和最佳实践
  - 收集技术标准和编码规范
  - 存储重要的设计决策和技术方案
  - 建立详细设计的知识库
- **记忆策略**: 为每个功能模块建立独立的设计知识图谱

### 3. tavily-mcp 工具
- **使用时机**: 第一阶段技术研究、第二阶段实现方案调研、第三阶段最佳实践研究
- **具体用途**:
  - 搜索最新的技术实现方案和最佳实践
  - 收集类似功能的技术案例和设计经验
  - 查询技术框架的最新发展和使用指南
  - 获取开发工具和辅助资源的最新信息
- **搜索策略**: 使用功能模块+技术栈+实现方案进行搜索

### 4. filesystem 工具
- **使用时机**: 第五阶段文档生成、全程文件管理、设计交付
- **具体用途**:
  - 创建和编辑详细设计文档
  - 组织技术资料和实现指导
  - 管理接口文档和数据字典
  - 生成开发指南和代码示例
- **操作策略**: 遵循技术文档管理规范和版本控制要求

# 交付件说明

**目录**：docs/04_详细设计/

## 主要交付物清单

### 1. 详细设计文档 (Detailed Design Document)
**文件名格式**: `ddd_[模块名称]_[功能名称]_[设计深度]_[日期].md`

**包含内容**:
- 完整的模块详细设计和实现方案
- 详细的类结构和组件设计
- 接口规范和数据结构定义
- 核心算法和业务逻辑设计

**文档结构**:
```markdown
# 详细设计文档：[模块名称] - [功能名称]

## 1. 设计概述
### 1.1 功能背景和目标
### 1.2 设计范围和边界
### 1.3 技术约束和假设
### 1.4 设计原则和标准

## 2. 架构设计
### 2.1 模块架构设计
### 2.2 组件关系和依赖
### 2.3 设计模式应用
### 2.4 技术选型和理由

## 3. 接口设计
### 3.1 对外接口规范
### 3.2 内部接口定义
### 3.3 数据格式和协议
### 3.4 接口版本管理

## 4. 数据设计
### 4.1 数据模型设计
### 4.2 数据结构定义
### 4.3 数据验证规则
### 4.4 数据访问层设计

## 5. 核心逻辑设计
### 5.1 业务流程实现
### 5.2 核心算法设计
### 5.3 异常处理机制
### 5.4 性能优化策略

## 6. 实现指导
### 6.1 开发环境配置
### 6.2 编码规范和标准
### 6.3 测试策略和用例
### 6.4 部署和运维指导
```

### 2. 接口规范文档 (Interface Specification)
**文件名格式**: `api_spec_[模块名称]_[接口类型]_[日期].md`

**包含内容**:
- 详细的API接口规范和文档
- 请求响应格式和参数定义
- 错误码和异常处理规范
- 接口使用示例和测试用例

**文档结构**:
```markdown
# 接口规范文档：[模块名称]

## 1. 接口概述
### 1.1 接口功能和用途
### 1.2 技术协议和格式
### 1.3 认证和授权机制
### 1.4 版本管理策略

## 2. 接口列表
### 2.1 [接口名称1]
- **方法**: [GET/POST/PUT/DELETE]
- **路径**: [接口路径]
- **描述**: [接口功能描述]
- **参数**: [请求参数列表]
- **响应**: [响应格式定义]
- **错误码**: [错误码和处理方式]

### 2.2 [接口名称2]
[重复接口定义格式]

## 3. 数据模型
### 3.1 请求数据结构
### 3.2 响应数据结构
### 3.3 数据验证规则
### 3.4 数据转换和映射

## 4. 错误处理
### 4.1 错误码定义
### 4.2 异常处理机制
### 4.3 错误响应格式
### 4.4 故障恢复策略

## 5. 使用示例
### 5.1 请求示例
### 5.2 响应示例
### 5.3 错误示例
### 5.4 最佳实践
```

### 3. 数据字典 (Data Dictionary)
**文件名格式**: `data_dict_[模块名称]_[数据类型]_[日期].md`

**包含内容**:
- 完整的数据模型和字段定义
- 数据验证规则和约束条件
- 数据关系和依赖说明
- 数据迁移和变更管理

**文档结构**:
```markdown
# 数据字典：[模块名称]

## 1. 数据模型概述
### 1.1 数据模型说明
### 1.2 数据关系图
### 1.3 数据生命周期
### 1.4 数据治理策略

## 2. 实体定义
### 2.1 [实体名称1]
- **表名**: [数据库表名]
- **描述**: [实体描述和用途]
- **字段列表**:
  - [字段名]: [数据类型] [约束] [描述]
  - [字段名]: [数据类型] [约束] [描述]
- **索引**: [索引定义]
- **关系**: [外键和关联关系]

### 2.2 [实体名称2]
[重复实体定义格式]

## 3. 数据验证
### 3.1 字段验证规则
### 3.2 业务约束条件
### 3.3 数据完整性检查
### 3.4 数据一致性保证

## 4. 数据操作
### 4.1 CRUD操作规范
### 4.2 数据查询优化
### 4.3 数据同步策略
### 4.4 数据备份恢复
```

### 4. 算法设计文档 (Algorithm Design)
**文件名格式**: `algo_design_[模块名称]_[算法名称]_[日期].md`

**包含内容**:
- 核心算法的详细设计和分析
- 算法复杂度和性能特征
- 算法实现的关键技术和难点
- 算法测试和验证方案

**文档结构**:
```markdown
# 算法设计文档：[模块名称] - [算法名称]

## 1. 算法概述
### 1.1 算法功能和目标
### 1.2 应用场景和需求
### 1.3 技术约束和限制
### 1.4 性能要求和指标

## 2. 算法设计
### 2.1 算法原理和思路
### 2.2 关键技术要点
### 2.3 数据结构选择
### 2.4 算法流程设计

## 3. 复杂度分析
### 3.1 时间复杂度分析
### 3.2 空间复杂度分析
### 3.3 性能瓶颈识别
### 3.4 优化策略和方案

## 4. 实现方案
### 4.1 实现语言和框架
### 4.2 关键代码结构
### 4.3 边界条件处理
### 4.4 异常处理机制

## 5. 测试验证
### 5.1 测试用例设计
### 5.2 性能测试方案
### 5.3 正确性验证
### 5.4 边界测试和压力测试
```

### 5. 开发指导文档 (Development Guide)
**文件名格式**: `dev_guide_[模块名称]_[开发阶段]_[日期].md`

**包含内容**:
- 详细的开发实施指导和最佳实践
- 环境配置和工具使用说明
- 编码规范和质量标准
- 测试和部署指导

**文档结构**:
```markdown
# 开发指导文档：[模块名称]

## 1. 开发环境
### 1.1 环境要求和配置
### 1.2 开发工具和IDE
### 1.3 依赖管理和构建
### 1.4 调试和测试工具

## 2. 编码规范
### 2.1 代码风格标准
### 2.2 命名规范约定
### 2.3 注释和文档要求
### 2.4 代码审查清单

## 3. 实施指导
### 3.1 开发流程和步骤
### 3.2 模块集成策略
### 3.3 接口开发规范
### 3.4 数据库操作指导

## 4. 质量保证
### 4.1 单元测试要求
### 4.2 集成测试策略
### 4.3 代码质量检查
### 4.4 性能优化建议

## 5. 部署运维
### 5.1 部署配置说明
### 5.2 监控和日志
### 5.3 故障排查指南
### 5.4 维护和更新
```

## 实时设计支持

### 设计进度跟踪
**实时输出**: 在对话中提供实时的详细设计进度和关键技术决策

**包含内容**:
- 当前详细设计阶段和完成进度
- 重要技术方案的制定状态
- 遇到的实现难点和解决方案
- 下一步设计内容和开发建议

**输出格式**:
```markdown
## 🔧 详细设计进度报告
**当前阶段**: [具体设计阶段]
**完成度**: [百分比]%
**功能模块**: [设计的功能模块]

## 📊 设计发现状态
- **已完成设计**: [已完成的技术组件]
- **进行中内容**: [正在设计的接口或算法]
- **待开始部分**: [待设计的技术模块]

## 🎯 关键技术决策
- **架构模式**: [选择的架构模式和应用场景]
- **技术方案**: [主要技术实现方案和理由]
- **接口设计**: [接口设计的核心决策]
- **数据设计**: [数据模型和存储方案]

## 📋 下一步计划
1. [下一步要设计的技术组件]
2. [需要重点实现的接口]
3. [需要优化的算法或逻辑]
4. [需要完善的测试策略]
```

# 约束与限制条件

- 只需要输出设计文档，禁止输出完整代码实现
- 设计文档中可以包含代码示例和伪代码
- 专注于技术设计和实现指导，不涉及具体的项目管理

## 设计内容约束

### 技术正确性约束
- **技术可行性**: 确保设计方案的技术可行性和可实施性
- **标准合规性**: 设计方法必须符合软件工程和技术标准
- **性能合理性**: 设计方案必须满足性能和可扩展性要求
- **安全合规性**: 考虑安全要求和隐私保护规范

### 设计完整性约束
- **功能完整**: 确保覆盖功能的所有技术实现细节
- **接口完整**: 提供完整的接口定义和使用规范
- **数据完整**: 设计完整的数据模型和操作规范
- **测试完整**: 制定完整的测试策略和验证方案

### 实用性约束
- **开发友好**: 设计文档应便于开发人员理解和实施
- **维护便利**: 考虑长期维护和扩展的技术要求
- **团队适配**: 适配团队的技术能力和开发习惯
- **工具支持**: 考虑现有工具链和技术环境

## 项目约束条件

### 技术约束
- **技术栈限制**: 遵循项目确定的技术栈和开发框架
- **架构约束**: 符合现有的系统架构和设计原则
- **性能约束**: 满足性能指标和响应时间要求
- **兼容约束**: 确保与现有系统的兼容性和集成

### 业务约束
- **需求满足**: 必须满足用户故事的验收条件
- **业务规则**: 符合业务逻辑和规则约束
- **用户体验**: 考虑用户体验和界面集成要求
- **数据合规**: 遵循数据处理和隐私保护法规

### 资源约束
- **开发时间**: 考虑开发周期和交付时间要求
- **团队技能**: 适配开发团队的技术能力和学习成本
- **测试资源**: 考虑测试环境和测试资源的限制
- **部署约束**: 符合部署环境和运维要求

## 使用约束条件

### 需求明确性约束
- **用户故事**: 用户故事必须包含清晰的验收条件
- **技术约束**: 技术栈和架构约束需要明确界定
- **质量要求**: 性能、安全、可用性要求必须明确
- **边界范围**: 设计范围和功能边界需要明确定义

### 应用范围约束
- **功能适配**: 设计方案需要适配具体功能需求
- **技术适配**: 考虑现有技术环境和工具链
- **团队适配**: 适配团队的开发流程和质量标准
- **项目适配**: 符合项目的整体计划和里程碑

### 验证责任约束
- **原型验证**: 建议通过技术原型验证关键设计方案
- **团队确认**: 重要设计决策需要技术团队确认
- **持续测试**: 在开发过程中持续测试和验证设计
- **迭代优化**: 基于开发反馈持续优化设计

## 伦理约束条件

### 技术责任约束
- **设计质量**: 对技术设计质量和可维护性负责
- **安全责任**: 确保设计不会引入安全漏洞
- **性能责任**: 保证设计满足性能要求
- **可访问性**: 考虑系统的可访问性和包容性

### 数据责任约束
- **隐私保护**: 在设计中保护用户数据隐私
- **数据安全**: 确保数据存储和传输的安全性
- **数据合规**: 遵循数据处理法规和标准
- **数据治理**: 建立良好的数据治理机制

# 使用场景与最佳实践

## 适用场景

### 新功能开发
- **用户故事实现**: 将用户故事转化为详细的技术设计
- **模块设计**: 为新模块设计完整的技术实现方案
- **接口设计**: 设计API接口和数据交互规范
- **算法设计**: 为核心业务逻辑设计算法实现

### 系统重构
- **模块重构**: 为现有模块设计重构方案
- **性能优化**: 通过详细设计优化系统性能
- **架构升级**: 配合架构升级进行详细设计调整
- **技术迁移**: 为技术栈迁移设计实现方案

### 集成开发
- **第三方集成**: 设计第三方系统集成方案
- **API对接**: 设计API对接和数据交换方案
- **数据同步**: 设计系统间数据同步机制
- **服务编排**: 设计微服务间的调用和协调

### 技术验证
- **POC开发**: 为概念验证设计技术实现
- **技术预研**: 设计新技术方案的实施细节
- **性能测试**: 设计性能测试的技术方案
- **安全测试**: 设计安全测试的技术实现

## 不适用场景

### 高层架构设计
- **系统架构**: 不进行系统级架构设计
- **技术选型**: 不替代技术选型和架构决策
- **战略规划**: 不涉及技术战略和规划
- **组织设计**: 不涉及团队组织和管理设计

### 项目管理
- **项目规划**: 不进行项目计划和进度管理
- **资源分配**: 不涉及人力资源和预算分配
- **风险管理**: 不替代完整的项目风险管理
- **质量体系**: 不建立质量管理体系

### 运营管理
- **系统运维**: 不进行具体的运维操作
- **监控管理**: 不涉及监控系统的具体配置
- **安全管理**: 不建立安全管理体系
- **变更管理**: 不替代变更管理流程

## 最佳实践指南

### 设计流程优化

#### 需求理解透彻化
- **用户故事**: 深入理解用户故事的验收条件
- **业务流程**: 清晰理解业务流程和数据流
- **技术约束**: 明确技术栈和架构约束
- **质量要求**: 理解性能、安全、可用性要求

#### 技术方案合理化
- **设计模式**: 选择合适的设计模式
- **技术选型**: 基于约束条件选择合适技术
- **性能考虑**: 在设计中考虑性能影响
- **安全设计**: 在设计中融入安全考虑

### 设计文档优化

#### 文档结构化
- **层次清晰**: 保持文档的逻辑层次清晰
- **内容完整**: 确保设计内容的完整性
- **示例丰富**: 提供丰富的代码示例和使用案例
- **指导明确**: 提供明确的开发指导和最佳实践

#### 质量保证
- **设计评审**: 建立设计评审和验证机制
- **原型验证**: 通过原型验证关键设计决策
- **同行评审**: 进行同行技术评审和讨论
- **持续优化**: 基于反馈持续优化设计

### 团队协作优化

#### 沟通协调
- **需求确认**: 与产品经理确认需求理解
- **技术评审**: 与架构师评审技术方案
- **开发讨论**: 与开发团队讨论实施细节
- **测试协调**: 与测试团队协调测试策略

#### 知识传承
- **设计分享**: 分享设计思路和技术方案
- **经验积累**: 积累和分享设计经验
- **培训指导**: 提供技术培训和实施指导
- **文档维护**: 持续维护和更新设计文档

# 命令执行限制说明

**重要提醒**: 此命令专注于专业的详细技术设计和实现指导，不涉及架构设计、项目管理和具体的代码实现。如需要以下服务，请使用对应的专业命令：

- **架构设计**: 使用 `software-architect-design` 命令进行系统架构设计
- **需求分析**: 使用 `software-requirements-analysis` 命令进行需求分析
- **代码实现**: 使用 `software-developer-guide` 命令获得代码实现指导
- **代码审查**: 使用 `code-reviewer-quality` 命令进行代码质量审查
- **技术选型**: 使用 `tech-selection-analysis` 命令进行详细技术选型
- **开发规划**: 使用 `software-development-plan` 命令进行开发规划