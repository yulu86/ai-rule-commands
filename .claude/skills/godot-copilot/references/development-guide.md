# Godot协同开发指导

## 协同开发模式概述

本技能采用AI与用户协同开发的模式，充分发挥各自优势：

- **AI负责**：脚本逻辑、算法实现、数据处理
- **用户负责**：场景设计、视觉布局、节点配置
- **共同协作**：测试调试、问题解决、项目优化

## 职责分工详解

### AI职责范围

#### 1. GDScript脚本开发
- 游戏逻辑实现
- 节点脚本编写
- 信号处理和事件响应
- 数据管理和状态控制
- 算法实现（AI、物理、数学计算等）

#### 2. GDShader着色器开发
- 视觉效果实现
- 自定义材质着色器
- 后处理效果
- 性能优化的着色器代码

#### 3. 工具脚本开发
- 编辑器工具插件
- 构建和部署脚本
- 自动化测试脚本
- 数据转换工具

### 用户职责范围

#### 1. 场景文件(.tscn)创建
- 节点树结构设计
- 节点属性配置
- 场景布局组织
- 资源引用设置

#### 2. 项目配置
- 项目设置管理
- 输入映射配置
- 层和分组设置
- 导出配置

#### 3. 节点引用处理
- 在脚本中正确引用场景节点
- 节点路径配置
- 信号连接设置

## 工作流程

### 第一阶段：需求分析
1. **用户提供**：游戏创意和基本需求
2. **AI分析**：技术可行性分析
3. **共同确认**：开发目标和范围

### 第二阶段：详细设计
1. **AI输出**：系统架构设计方案
2. **用户反馈**：设计调整建议
3. **共同完善**：最终设计文档

### 第三阶段：协同开发
1. **用户创建**：基础场景结构
2. **AI开发**：功能脚本逻辑
3. **集成测试**：功能验证和调试

### 第四阶段：优化完善
1. **性能分析**：识别瓶颈和问题
2. **分工优化**：针对性改进
3. **质量保证**：最终测试和发布

## 具体操作指南

### 场景创建流程（用户）

#### 1. 基础场景结构
```
Main.tscn (主场景)
├── UI (CanvasLayer)
│   ├── HUD
│   ├── Menu
│   └── PauseMenu
├── World (Node2D/Node3D)
│   ├── Player
│   ├── Enemies
│   ├── Environment
│   └── Collectibles
└── AudioManager
```

#### 2. 节点配置步骤
1. **创建根节点**：根据游戏类型选择合适的根节点
2. **添加子节点**：按功能分组组织节点
3. **设置属性**：配置节点的基本属性
4. **添加组件**：添加必要的组件节点
5. **保存场景**：定期保存场景文件

#### 3. 常见节点类型
- **Node2D**：2D游戏基础节点
- **Node3D**：3D游戏基础节点
- **CharacterBody2D/3D**：角色控制节点
- **RigidBody2D/3D**：物理模拟节点
- **Area2D/3D**：触发检测节点
- **Sprite2D**：2D精灵显示节点
- **Camera2D/3D**：摄像机节点
- **CanvasLayer**：UI层级节点

### 脚本开发流程（AI）

#### 1. 脚本创建顺序
```gdscript
# 1. 主控脚本 (Main.gd)
extends Node

# 2. 玩家脚本 (Player.gd)
extends CharacterBody2D

# 3. 敌人脚本 (Enemy.gd)
extends CharacterBody2D

# 4. UI脚本 (HUD.gd)
extends CanvasLayer

# 5. 管理器脚本 (GameManager.gd)
extends Node
```

#### 2. 脚本基本结构
```gdscript
# 类声明和继承
extends CharacterBody2D
class_name Player

# 导出的变量（可在编辑器中设置）
@export var speed: float = 300.0
@export var jump_velocity: float = -400.0

# 内部变量
var health: int = 100
var is_dead: bool = false

# 节点引用
@onready var sprite: Sprite2D = $Sprite2D
@onready var collision: CollisionShape2D = $CollisionShape2D

# 生命周期方法
func _ready():
    # 初始化代码
    pass

func _physics_process(delta):
    # 物理处理代码
    pass

func _process(delta):
    # 每帧处理代码
    pass

# 自定义方法
func take_damage(amount: int):
    health -= amount
    if health <= 0:
        die()

func die():
    is_dead = true
    # 死亡逻辑
```

#### 3. 信号处理模式
```gdscript
# 发送信号
signal health_changed(new_health)
signal player_died

# 连接信号（在_ready中）
func _ready():
    health_changed.connect(_on_health_changed)
    player_died.connect(_on_player_died)

# 信号处理函数
func _on_health_changed(new_health: int):
    # 更新UI显示
    pass

func _on_player_died():
    # 处理玩家死亡
    pass
```

### 集成和测试流程

#### 1. 功能测试步骤
1. **用户确认**：场景结构已创建完成
2. **AI开发**：对应的脚本逻辑
3. **集成测试**：运行项目验证功能
4. **问题反馈**：记录测试中的问题
5. **迭代修复**：分工解决具体问题

#### 2. 调试协作模式
- **用户描述**：问题现象和重现步骤
- **AI分析**：可能的原因和解决方案
- **用户测试**：解决方案的验证
- **AI优化**：基于测试结果的代码优化

## 沟通协作技巧

### 有效沟通方式

#### 1. 问题描述模板
```
【问题类型】：功能异常/性能问题/显示错误
【发生场景】：具体的操作步骤
【期望行为】：应该出现的正常结果
【实际行为】：实际发生的异常情况
【错误信息】：控制台或编辑器中的错误提示
```

#### 2. 需求描述模板
```
【功能需求】：需要实现的具体功能
【使用场景】：功能在什么情况下使用
【技术要求】：性能、兼容性等技术限制
【优先级】：功能开发的重要程度
```

#### 3. 反馈意见模板
```
【满意度】：对当前实现的满意程度
【修改建议】：具体的改进建议
【新增需求】：发现的新功能需求
【技术问题】：遇到的技术困难
```

### 版本控制协作

#### 1. 提交信息规范
- **feat**：新功能实现
- **fix**：问题修复
- **refactor**：代码重构
- **test**：测试相关
- **docs**：文档更新
- **style**：代码格式调整

#### 2. 分支管理
- **main**：稳定发布版本
- **develop**：开发集成版本
- **feature/***：功能开发分支
- **hotfix/***：紧急修复分支

## 常见问题和解决方案

### 技术问题

#### 1. 节点引用问题
```
问题：脚本无法找到场景节点
解决：
- 用户检查节点路径是否正确
- AI验证@onready变量声明
- 确认节点在场景树中的层级关系
```

#### 2. 信号连接问题
```
问题：信号无法触发或响应
解决：
- AI检查信号定义和连接代码
- 用户确认场景中的信号连接设置
- 验证信号参数匹配
```

#### 3. 性能问题
```
问题：游戏运行卡顿或内存占用过高
解决：
- AI分析脚本性能瓶颈
- 用户检查场景复杂度
- 共同优化渲染和计算逻辑
```

### 协作问题

#### 1. 需求理解偏差
```
解决方案：
- 详细的需求文档确认
- 原型快速验证
- 定期进度同步
```

#### 2. 技术实现分歧
```
解决方案：
- 技术方案讨论
- 性能对比测试
- 最佳实践参考
```

## 质量保证

### 代码质量标准
- **可读性**：清晰的命名和注释
- **性能**：高效的算法实现
- **可维护性**：模块化和解耦设计
- **安全性**：错误处理和边界检查

### 测试标准
- **功能测试**：所有功能正常工作
- **性能测试**：帧率和内存使用正常
- **兼容性测试**：目标平台正常运行
- **用户体验测试**：操作流畅，界面友好

### 文档标准
- **API文档**：脚本接口说明
- **使用指南**：功能使用方法
- **维护文档**：常见问题和解决方案